Java is a high-level programming language that is similar to C++ in many ways. The biggest difference between C++ and Java is that while C++ programs are compiled to a sequence of assembly language instructions (also called native code) for execution by the CPU, Java is executed by a separate program called the Java Virtual Machine (JVM). Specifically, the Java compiler converts the Java program into a byte-code file, which is then used by the JVM to execute the program. 

There is significant controversy over whether C++ is preferred to Java, or vice verse. Some advantages of Java over C++ are listed below.

\begin{enumerate}
\item The JVM can ensure that a Java program has precisely the same functionality across computers with different hardware architectures. The functionality of C++ is hardware dependent.
\item Java does not have pointers, and as a result it avoids run-time errors resulting from accessing invalid memory.
\item Java has automatic garbage collection, which eliminates the need to manually specify when allocated memory is no longer needed\footnote{The new C++11 standard includes a smart pointer mechanism that provides garbage collection. The Java formalism, however, is more natural and easy to use.}.
\item Java has a much larger standard library than C++, including better support for multi-threading, networking, databases, and graphics.
\end{enumerate}

Some advantages of C++ over Java are listed below. 

\begin{enumerate}
\item Java was invented by Sun, and is now owned by Oracle. Many aspects of it are free, but not all. Specifically, Oracle allows the free usage of Java on desktops and server platforms, but may require royalty payments for the usage of Java in embedded systems.
\item The usage of the JVM has computational overhead, and the process of running byte code instructions is often slower than running native code. This implies that in some cases Java programs are slower than C++ programs. \end{enumerate}

The computational overhead of the Java (as opposed to compiled C++ code) is often cited as a significant weakness of Java. In recent years, however, Java's overhead declined due to the use of advanced just-in-time (JIT) compilation. JIT compilation identifies computational bottlenecks, also known as hot-spots, and compiles them into native code. As a result, the computational efficiency gap between Java and C++ programs has narrowed significantly. In theory, Java programs may even run faster than C++ since the Java JIT compiler has access to optimization techniques that are not available to the C++ compiler. In practice, however, C++ is usually preferred to Java when computational efficiency is paramount. 

Java is similar to C++ in many ways. We therefore structure this chapter similarly to Chapter~\ref{chap:c}. We also make references to relevant parts of Chapter~\ref{chap:c} in order to avoid duplicating a large part of Chapter~\ref{chap:c}. 

\section{Compilation}

The Java environment is divided to two components: the Java compiler and the Java virtual machine (JVM). In Linux, the Java compiler is available as the program \texttt{javac} and the JVM is available through the program \texttt{java} (in Linux, both \texttt{javac} and \texttt{java} are typically placed in the directory \texttt{/usr/bin/}). The Java software, known as the Java Development Kit (JDK), is available for download from Oracle's website \href{http://www.oracle.com/technetwork/java/javase/downloads}{http://www.oracle.com/technetwork/java/javase/downloads} (current version is JDK 8.0).

The Java compiler program, \texttt{javac}, takes as input a Java program and produces a file containing the Java byte code. The \texttt{java} program takes as input the byte code file and runs it within the JVM. 

Files containing Java programs typically have a \texttt{.java} suffix and files containing Java byte code typically have a \texttt{.class} suffix (the \texttt{.class} suffix should be omitted when calling the \texttt{java} program on a byte code file -- see below for an example). It is convenient to add the directory path for \texttt{java} and \texttt{javac} to the operating system \texttt{PATH} variable so these programs are recognized without specifying the full path (see Chapter~\ref{chap:os}).

As in C++, Java code is composed of a sequence of case-sensitive statements separated by semi-colons and arranged in functions and classes. The function \texttt{main} is special in that the CPU executes its code whenever the JVM executes the corresponding byte code file. 

As in C++, Java code is often annotated with comments that provide documentation on the code. Such comments are ignored by the compiler and thus they do not affect the program's functionality. As in C++, there are two ways to define comments in Java:  (a) text following \texttt{//} that continues until the end of the line, and (b) text between the symbols \texttt{/*} and \texttt{*/} (possibly spanning multiple lines). 

The code describing the Java program resides in a \texttt{main} function, as in C++. But in contrast to C++, the \texttt{main} function needs to be a static member function of a class whose name matches the file containing the Java code. The \texttt{main} function in Java does not return any value (marked by a \texttt{void} return value).

For example, the following Java code contains a simple program that prints a greeting message in the operating system terminal. Note that \texttt{main} is a static member function of the class \texttt{print\_greeting}. The function \\ \noindent \texttt{System.out.println} is a Java function that prints to the console its argument, followed by a new line character. 

<<engine="Rcpp",eval=FALSE>>=
public class print_greeting { 
   public static void main(String[] args) { 
      System.out.println("Hello, World!");
   }
}
@ 

In order to compile and run the program, we need to save the code above in a file whose name matches the class containing the \texttt{main} function: \\ \noindent \texttt{print\_greeting.java}. Running the Java compiler on this file produces the file \texttt{print\_greeting.class} that contains byte code. To execute the program we need to call the \texttt{java} program, specifying the name of the byte code file as an argument, without its \texttt{.class} suffix.

<<engine="bash",eval=FALSE>>=
# Compile print_greeting.java file containing Java code to byte code
javac print_greeting.java  
# The byte code now resides in the file print_greeting.class.
# Execute byte code file in JVM using the java program 
# (omit .class suffix)  
java print_greeting

## Hello, World!
@ 

In many cases a Java program is spread across multiple files. We may have one file with the class containing the \texttt{main} function and other files containing related classes. To compile the program, run the Java compiler (\texttt{javac}) with arguments corresponding to all of the files (possibly using  filename wildcards to avoid writing a long list of filenames -- see Chapter~\ref{chap:os}). To execute the program, run the \texttt{java} program with an argument corresponding to the class containing the \texttt{main} function. 

It is possible to have multiple \texttt{main} functions, for example each class may have its own \texttt{main} function. One reason for doing so is having a \text{main} function representing the primary executable program and other \texttt{main} functions corresponding to auxiliary programs that test the code in the corresponding classes. After compilation, the correct \texttt{main} function can be executed by supplying the java program with the appropriate byte code file.

We proceed below to explore the Java programming language. We start with low level features such as variables, control flow, functions, and input and output. We continue with object oriented programming, and follow up with generics and the Java collections, which correspond to the C++ concepts of templates and STL (see Chapter~\ref{chap:c}).

\section{Types, Variables, and Scope} \label{sec:java:typesVar}

Java types and variables are very similar to C++ types and variables. We refer the reader to Section~\ref{sec:c:typesVar} for more information on types and variables. 

A few key differences between Java and C++ are described below.

\begin{enumerate}
\item The Java type \texttt{char} uses 16 bits to represent unicode characters (unicode is a set of characters than include Asian, Arabic, and other characters in addition to the ASCII characters). The 
Java type \texttt{byte} uses 8 bits to represent integers in the range $-128,\ldots,127$. 
\item The Java type \texttt{boolean} represent boolean values. The possible values are \texttt{true} and \texttt{false} as in C++ \texttt{bool} type. 
\item In Java, the number of bits each type uses (and consequentially the range of possible values and approximation quality in the case of floating point representations) is hardware independent. For example, \texttt{int} uses 4 bytes to represent integers in a range that is approximately $\pm 2$ billion, while \texttt{long} uses 8 bytes. Similarly, \texttt{float} uses 4 bytes to represent values in a range that is approximately $\pm 3\cdot 10^{38}$ (up to 6-7 significant digits) while \texttt{double} uses 8 bytes to represent values in a range that is approximately $\pm 1.7 \cdot 10^{308}$ (up to 15 significant digits). 
\item Uninitialized Java variables cannot be accessed until they are initialized. 

<<engine="bash",eval=FALSE>>=
public class var_init { 
  public static void main(String[] args) { 
    int a = 3;
    System.out.println(a); // ok; prints 3
    int b;
    b = 3;
    System.out.println(b); // ok; prints 3
    int c;
    System.out.println(c); // error: c is not initialized
  }
}
@

\item Java uses the keyword \texttt{final} to represent variables that may not be modified, instead of the C++ keyword \texttt{const}. For example, a variable defined as \texttt{final int a = 3} cannot be modified later on. 
\end{enumerate}

\section{Operators and Casting} \label{sec:java:operators}

Operators and casting in Java is very similar to C++. We refer the reader to Section~\ref{sec:c:operators} for more information on operators and casting. 

One important difference between Java and C++ is that Java is less aggressive in applying implicit casting than C++.  As a result, Java is considered more strongly typed than C++. For example, Java integers cannot be implicitly cast to a \texttt{boolean} type.

For example, the expression \texttt{int a=0; if (a) a=1;} is legal in C++ but illegal in Java since the integer \texttt{a} in \texttt{(a)} needs to be converted to a boolean variable. Similarly, the Java expression \texttt{int a = 3.2;} is illegal as implicit casting is not pursued. 

\section{Primitive and Non-Primitive Types} \label{sec:java:nonPrimitive}

As mentioned in Section~\ref{sec:java:typesVar}, primitive variables in Java behave very similarly to C++ variables. 

Java also has classes and objects that are very similar to the corresponding C++ concepts. Classes are collections of variables, called fields, and functions, called methods. An object is an instantiation of a class in the same way that a primitive variable is an instantiation of a type. Once an object of a certain class is defined, its fields and methods can be called using the period operator. For example, if \texttt{x} is an object then \texttt{x.field\_name} or \texttt{x.method\_name(...)} refer to the field \texttt{field\_name} and the function \texttt{method\_name} that are associated with the object \texttt{x}. 

Defining non-primitive objects in Java requires the usage of the \texttt{new} statement, as in the case of allocating dynamic memory in C++. Assigning one object to another does not create a copy of the object but instead makes both objects refer to the same memory content, and changing one object will cause the other object to change as well. In other words, Java objects behave like pointers to dynamically allocated memory in C++ (without the need for the C++ pointer operators \texttt{*} and \texttt{\&}).  

For example, the code below defines an object of class \texttt{Date} and then assigns that object to a new object. Since both objects point to the same memory location, modifying the second object causes the first object to change as well. 

<<engine="Rcpp",eval=FALSE>>=
import java.util.Date;

public class date_example {
  public static void main(String[] args) {
    Date date1 = new Date(); // define a new object date1
    Date date2 = date1; // assign date1 to a new object date 2
    // print both objects
    System.out.println(date1);
    System.out.println(date1);
    // Both objects date1 and date2 refer to the same memory 
    // Modifying date2 changes date1 as well
    date2.setTime(1);
    // print both objects
    System.out.println(date1);
    System.out.println(date1);
  }
}
@

Compiling and executing the code above gives the following output. 

<<engine="Rcpp",eval=FALSE>>=
## Wed Apr 24 18:02:49 PDT 2013
## Wed Apr 24 18:02:49 PDT 2013
## Wed Dec 31 16:00:00 PST 1969
## Wed Dec 31 16:00:00 PST 1969
@

In an analogous C++ program, the assignment \texttt{date2 = date1} would have created a new object \texttt{date2} that is a copy of \texttt{date1} and subsequent modification of \texttt{date2} would not modify \texttt{date1}. 

This pointer-like behavior of Java objects\footnote{Java does not have references or pointers.} applies to any non-primitive type, including arrays, strings, and user-defined classes. 

In addition to primitive types such as \texttt{int}, \texttt{double}, and \texttt{boolean} Java has corresponding wrapper classes \texttt{Integer}, \texttt{Double}, and \texttt{Boolean}. These classes allow defining objects that hold basic numeric types, but have additional functionality such as class methods that can be used. For example the \texttt{Integer} class defines methods for converting between from string to an \texttt{Integer} and vice verse. 

<<engine="Rcpp",eval=FALSE>>=
// creating an Integer object with value 2
Integer n = Integer.valueOf(2);  
// call method of Integer to transform value to string
String s = n.toString();
@


Java's auto-boxing functionality allows using primitive types when the corresponding objects are expected. Similarly, the un-boxing functionality allows using objects when the corresponding primitive types are expected. 

<<engine="Rcpp",eval=FALSE>>=
Integer n1 = 2; // auto-boxing
int n2 = n1; // un-boxing
@

\section{Arrays} \label{sec:java:arrays}

Java arrays correspond to the C++ concept of pointers to dynamically allocated memory containing sequences of variables or objects. 

Below are some key differences and similarities between arrays in Java and C++. 

\begin{enumerate}
\item In Java, the type of an array holding variables or objects of type \texttt{A} is \texttt{A[]}. Thus, the statement \texttt{int[] x = new int[10]} defines an array of 10 elements of type \texttt{int}. 
\item The size of a Java array does not need to be known during compilation. 
\item The size of a Java array cannot be modified after it is defined.
\item There is no need to explicitly free the allocated memory when the array is no longer needed. The JVM's garbage collection mechanism takes care of that automatically.
\item The JVM performs range checking on Java arrays, and does not allow accessing elements that are outside of the range of the allocated array. Such a violation in Java will result in a compilation error, a significant improvement over returning the wrong answer or suffering a run-time crash as may happen in C++.
\item If \texttt{x} is a Java array, the expression \texttt{x.length} returns the size of the array.
\item Assigning one array to another \texttt{x = y} has the effect of having both arrays refer to the same memory content.
\end{enumerate}

\subsection{One Dimensional Arrays}

The statement \texttt{A[] x = new A[n]} defines a new array \texttt{x} of size \texttt{n}, holding primitive variables or objects of type \texttt{A}. The array elements can be accessed using the square bracket notation, for example \texttt{x[k]} refers to the \texttt{k+1} element of the array \texttt{x}.

Traversing the array can be done using a for-loop with an index variable (the \texttt{length} field can be used to limit the index variable) or using a range for-loop. See Section~\ref{sec:c:forLoops} for more information on C++ for-loops, which are identical to Java for-loops. 

<<engine="bash",eval=FALSE>>=
public class array_example { 
  public static void main(String[] args) { 
    int n = 10;
    int[] ar = new int[n]; 
    for (int i = 0; i < ar.length; i++) 
      ar[i] = i;
    for (int e : ar) 
      System.out.print(e + " ");
  }
}
@

Compiling and executing the above program displays the following output. 

<<engine="bash",eval=FALSE>>=
## 0 1 2 3 4 5 6 7 8 9
@

Adding to the program above the line \texttt{ar[12] = 3} yields a compilation error as an element outside the array boundary is accessed. 
 
\subsection{Multidimensional Arrays}

Multidimensional arrays in Java are essentially arrays of arrays. They are represented by a double square bracket notation. 

<<engine="bash",eval=FALSE>>=
public class array_example_2d { 
  public static void main(String[] args) { 
    int[][] ar = new int[10][10];
    for (int i = 0; i < ar.length; ++i)
      for (int j = 0; j < ar[i].length; ++j)
        ar[i][j] = i * 10 + j;
    for (int i = 0; i < ar.length; ++i) {
      for (int j = 0; j < ar[i].length; ++j) {
        System.out.print(ar[i][j] + " ");
      }
      System.out.print("\n");      
    }
  }
}
@

Compiling and executing the above program displays the following output. 

<<engine="bash",eval=FALSE>>=
## 0 1 2 3 4 5 6 7 8 9
## 10 11 12 13 14 15 16 17 18 19
## 20 21 22 23 24 25 26 27 28 29
## 30 31 32 33 34 35 36 37 38 39
## 40 41 42 43 44 45 46 47 48 49
## 50 51 52 53 54 55 56 57 58 59
## 60 61 62 63 64 65 66 67 68 69
## 70 71 72 73 74 75 76 77 78 79
## 80 81 82 83 84 85 86 87 88 89
## 90 91 92 93 94 95 96 97 98 99
@

Some of the array elements in a two dimensional array may be arrays of different lengths (ragged array).

<<engine="Rcpp",eval=FALSE>>=
public class class array_example_2d_ragged  { 
   public static void main(String[] args) { 
     int[][] ar = new int[10][];
     for (int i = 0; i < ar.length; ++i)
       ar[i] = new int[i+1];  
     for (int i = 0; i < ar.length; ++i)
       for (int j = 0; j < ar[i].length; ++j)
         ar[i][j] = i * 10 + j;
     for (int i = 0; i < ar.length; ++i) {
       for (int j = 0; j < ar[i].length; ++j) {
         System.out.print(ar[i][j] + " ");
       }
       System.out.print("\n");      
     }
  }
}
@


Compiling and executing the above program displays the following output. 

<<engine="bash",eval=FALSE>>=
## 0
## 10 11
## 20 21 22
## 30 31 32 33
## 40 41 42 43 44
## 50 51 52 53 54 55
## 60 61 62 63 64 65 66
## 70 71 72 73 74 75 76 77
## 80 81 82 83 84 85 86 87 88
## 90 91 92 93 94 95 96 97 98 99
@


\section{Packages and the Import Statement}

A package in Java is a collection of classes. By convention, packages are  organized in a hierarchy that reflects the semantic role of the individual packages. 

Packages allow multiple developers to work on different programs independently without worrying that their classes and variables have identical names. A class is recognized in a program if it is prefixed by the package name followed by a period. Thus if we have two classes with the same name \texttt{A} in two different packages \texttt{p1} and \texttt{p2}, we can distinguish the two classes by referring to them as \texttt{p1.A} and \texttt{p2.A}. 

For example, we can refer to the class \texttt{Date} in the  \texttt{java.util} package by adding the appropriate prefix whenever the class is referred. 

<<engine="Rcpp",eval=FALSE>>=
java.util.Date date1 = new java.util.Date();
@

This cumbersome prefix notation can be avoided by including an \texttt{import} statement followed by the class or package name at the top of the Java program. Import statements may refer to specific classes, in which case the \texttt{import} statement is followed by the name of the package followed by the name of the class (separated by a period). Import statements can also refer to entire packages using the wildcard notation \texttt{*}. 

For example, the code below uses the class \texttt{Date}, defined in the package \texttt{java.util}, without the prefix notation.

<<engine="Rcpp",eval=FALSE>>=
import java.util.Date;
...
Date date1 = new Date();
@

Alternatively, we can import the entire package \texttt{java.util}.

<<engine="Rcpp",eval=FALSE>>=
import java.util.*;
...
Date date1 = new Date();
@

Packages may be created by including the statement \texttt{package package\_name} at the top of the Java program. To create a hierarchy of packages, the hierarchy must correspond to the constituents of the package name (separated by periods), and files must be placed in file directories with the corresponding directory hierarchy. 

Class files can also be stored in a Java archive (JAR) file, which is a compressed archive containing a hierarchy of directories corresponding to a hierarchy of packages. A JAR file is convenient since it is a single file (rather than a directory) and it is stored in a compressed format. The classes and packages in the JAR file will be recognized if the class path environment variable includes the path to the directory containing the JAR file, or if the \texttt{java} command uses the flag \texttt{-classpath} followed by the appropriate directory. 

<<engine="Rcpp",eval=FALSE>>=
# modifying the class path in bash, using : as separator 
# (period corresponds to current directory)
export CLASSPATH=/home/joe/classes:/home/jane/classes:.

# alternatively, the class path can be passed as an 
# argument to java
java -classpath /home/joe/classes:/home/jane/classes:. program.java
@

\section{Strings, Input, and Output}

The \texttt{String} class in Java offers functionality that is similar to the C++ \texttt{string} class. One difference is that the Java \texttt{String} is immutable i.e., a \texttt{String} object cannot be modified after it is initialized. 

Java \texttt{String} objects cannot use square brackets to refer to specific characters in the string as in C++, but the addition operator \texttt{+} implements concatenation on \texttt{String} objects as it does in C++. If \texttt{+} appears between a string and a non-string object, the non-string object is converted to a string (if possible), and concatenated with the string object. 

The example below defines a \texttt{String} object \texttt{greeting}, prints the second character using the member function \texttt{charAt}, checks whether \texttt{greeting} is equal to the string \texttt{Hello} (it is), and then concatenates the substring \texttt{Hel} with \texttt{p}.

<<engine="bash",eval=FALSE>>=
public class print_greeting { 
   public static void main(String[] args) { 
    String greeting = "Hello";
    System.out.println(greeting);
    System.out.println(greeting.charAt(2));
    System.out.println(greeting.equals("Hello"));
    System.out.println(greeting.substring(0,3) + "p");
   }
}
@

Compiling and executing the above program gives the following output. 

<<engine="bash",eval=FALSE>>=
## Hello
## l
## true
## Help
@


\section{Control Flow}

Control flow in Java is very similar to control flow in C++. Please refer to Section~\ref{c:controlFlow} for more information. See Section~\ref{sec:java:arrays} for several concrete examples of using for-loops in Java. 

\section{Functions}

Functions in Java are similar to functions in C++. See Section~\ref{sec:c:functions} for relevant information on C++ functions, including recursion and parameter overloading.  We describe below three key differences between functions in Java and functions in C++. 

The first key difference is that all Java functions are methods (member functions in a class). C++ as methods in addition to stand alone function.

The second key difference is in the way arguments are passed. Passing primitive types (for example \texttt{int} or \texttt{double}) as function arguments in Java behaves as it does in C++. On the other hand, passing objects as function arguments in Java behaves in the same way as passing pointers to the corresponding objects in C++.  For example, if an object in Java is passed to a function, any modification to the argument inside the function will persist after the function terminates. 

For example, the code below defines two functions that modify their arguments. The first function accepts a primitive variable of type \texttt{int} and the second function accepts an array. Changes made by the first function to the argument do not persist after the function terminates while changes made by the second function does persist.

<<engine="Rcpp",eval=FALSE>>=
public class function_argument_example {
  static void foo1(int a) {
    a = 1;
  }  
  static void foo2(int[] arr) {
    arr[0] = 1;
  }  
  public static void main(String[] args) {
    int a = 3; 
    System.out.println("primitive variable a before foo1: " + a);
    foo1(a); 
    System.out.println("primitive variable a after foo1: " + a);
    int[] b = new int[1];
    b[0] = 3;
    System.out.println("array element b[0] before foo2: " + b[0]);
    foo2(b); 
    System.out.println("array element b[0] after foo2: " + b[0]);
  }
}
@

Compiling and executing the code above gives the following output. 

<<engine="Rcpp",eval=FALSE>>=
## primitive variable a before foo1: 3
## primitive variable a after foo1: 3
## array element b[0] before foo2: 3
## array element b[0] after foo2: 1
@

The third key difference between C++ and Java functions is the way arguments are passed to \texttt{main}. In Java the argument of \texttt{main} is an array of string objects, \texttt{string[] args}, where \texttt{args[0]} contains the first parameter, \texttt{args[1]} contains the second parameter, and so on.

\section{Object Oriented Programming} \label{sec:java:oop}

\subsection{Classes}

As in C++, Java classes is a collection of primitive variables and objects (called fields), and functions (called methods). An object is an instantiation of a class, in the same way that a primitive variable is an instantiation of a primitive type. As in C++, the fields and methods of an object are referenced using the period operator. See Section \ref{sec:c:classes} for the details of C++ classes, most of which apply to Java classes as well. Some important differences between classes in C++ and Java are listed below. 

\begin{itemize}
\item In contrast to C++, in Java we need to prefix each field or method definition by its access modifier (for example \texttt{public} or \texttt{private}). C++ uses the labels \texttt{public:} and \texttt{private:} to label as public or private all subsequent fields and methods. 
\item Java does not require a semicolon after a class definition. 
\item In Java, objects must be defined using dynamic memory allocation, for example using the following statement \texttt{point p1 = new point()}. In C++, objects can be defined using dynamic memory allocation (\texttt{point p1 = new point()}) or using static memory allocation (\texttt{point p1()}). Since Java has automatic garbage collection, the dynamically allocated memory does not need to be explicitly freed.
\item Java uses the method \texttt{finalize} instead of the C++ destructor. 
\item The \texttt{this} keyword in Java refers to the current object, rather than a pointer to the current object as it does in C++. Thus the C++ statement \texttt{this->field\_name} becomes \texttt{this.field\_name} in Java.
\item Static fields and methods in Java are accessed using the period operator prefixed with the class name (rather than the C++ \texttt{::} operator). Thus, the C++ statement \texttt{my\_class::static\_field} is equivalent to the Java statement \texttt{my\_class.static\_field}. 
\item In Java, fields that are not explicitly initialized by the constructor, are initialized to default values. This is in contrast to variables that are not fields (for example local variables defined in a method), which must be explicitly initialized before their use.
\end{itemize}

The example below defines a class that is similar to the C++ \texttt{point} class from the previous chapter. Our example contains two classes, both of which exist in a single Java file \texttt{point\_example.java}. The first class corresponds to the concept of a point in a two dimensional space, and the second class holds the \texttt{main} function. Note that the file name should match the name of the class containing the \texttt{main} function. 

<<engine="Rcpp",eval=FALSE>>=
class point {
  private double x;
  private double y;
  public point() { // empty constructor
    x = 0;
    y = 0;	
  }
  public point(int nx, int ny) { // non-empty constructor
    x = nx;
    y = ny;	
  }
  public void set_x(double nx) {
    x = nx;	
  }
  public void set_y(double ny) {
   y = ny;	
  }
  public double get_x() { 
    return(x);
  }
  public double get_y() {
    return(y);	
  }
  public void reflect() {
    x = -x;
    y = -y;	
  }
}

public class point_example {
  public static void main(String[] args) {
    point p = new point();
    p.set_x(1);
    p.set_y(2);
    System.out.println("(" + p.get_x() + "," + p.get_y() + ")");
    p.reflect();
    System.out.println("(" + p.get_x() + "," + p.get_y() + ")");
  }
}
@

Compiling the above program with the \texttt{javac} program creates two byte code files \texttt{point\_example.class} and \texttt{point.class}. To execute the program we need to call the JVM with the byte code file corresponding to the class that contains the \texttt{main} function: \texttt{java point\_example}. This gives the following output. 

<<engine="bash",eval=FALSE>>=
## (1.0,2.0)
## (-1.0,-2.0)
@

Recall that objects in Java behave semantically like pointers to objects in C++. This means that assigning one object to another makes both refer to the same memory and changing the fields through one object will persist when the fields are accessed though the other object. The \texttt{clone} method in Java provides a way to create a copy of an existing object.

For example, in the following code both \texttt{p1} and \texttt{p2} refer to the same object in memory so that when the object is reflected by \texttt{p2}, the change appears also when we access \texttt{p1}.

<<engine="bash",eval=FALSE>>=
public class point_example {
  public static void main(String[] args) {
    point p1 = new point(1,2);
    point p2 = p1;
    p2.reflect();  // note: p1 is also modified
    System.out.println("(" + p1.get_x() + "," +          p1.get_y() + ")");
  }
}
@

Compiling and executing the above program gives the following output. 

<<engine="bash",eval=FALSE>>=
## (-1.0,-2.0)
@


In C++ there is only one way to initialize the fields, using a constructor. In Java there are two additional ways for initializing the fields, listed below.

\begin{enumerate}
\item Assigning values to fields inside the class definition initializes the fields to the corresponding values before a constructor is executed. If static fields are initialized during their definition, the initialization is carried out only once -- when the class is loaded at run-time. 
\item An initialization block is a sequence of Java statements inside curly braces, that lies inside a class definition. The block is executed whenever an object is constructed. Static fields can be initialized using static initialization blocks, which are prefixed by the keyword \texttt{static}.
\end{enumerate}

The code below demonstrates these two alternative field initialization methods.

<<engine="Rcpp",eval=FALSE>>=
class point {
  private double x = 0;  // initialization during field definition
  private double y;
  {
    y = 2;  // initialization block	
  }
}
@

\subsection{Inheritance}

Inheritance in Java is similar to inheritance in C++. Section~\ref{sec:c:inheritance} contains details and examples of inheritance in C++.  We use the Java terminology of superclass and subclass rather than the C++ terminology of base class and derived class. 
The important differences between Java and C++ are listed below. 

\begin{enumerate}
\item Inheritance in Java is marked using the \texttt{extends} keyword, rather than the C++ \texttt{:} operator.
\item In Java, the keyword \texttt{this} can be used to call the constructor or refer to the current object. The keyword \texttt{super} can be used to refer to the superclass or call the constructor of the super-class. For example, within a subclass we can refer to a superclass method using \texttt{super.method\_name()} and call the superclass constructor using \texttt{super()}. 
\item Denoting a class as final (by adding the prefix \texttt{final} before the class definition) prevents other classes from inheriting from it. 
\item C++ implements static binding by default, and dynamic binding requires defining the appropriate method as \texttt{virtual} (see Section \ref{sec:c:polymorphism}). Java implements dynamic binding by default, and there is no need to explicitly specify a method as virtual. 
\item If class \texttt{A} is the superclass of class \texttt{B}, in C++ a pointer of type \texttt{A*} can point to an object of class \texttt{B}. This allows the use of polymorphism, for example having a single array containing pointers to objects of classes \texttt{A} and \texttt{B}. Java has no pointers, but it allows an object of a subclass \texttt{B} to be assigned to an object of the superclass \texttt{A} (or to an element of an array of type \texttt{A[]}). If an object of type \texttt{A} refers to an object of type \texttt{B}, then only the functionality of \texttt{A} can be used. Casting the object back to type \texttt{B} allows using the full functionality of the subclass \texttt{B}.
\end{enumerate}


<<engine="Rcpp",eval=FALSE>>=
class Parent { // superclass 
  int a;
  Parent(int na) { // constructor of Parent
    a = na;	
  } 
}

class Child extends Parent { // subclass
  int b;
  Child(int na, int nb) {
    super(na); // call to constructor of class Parent
    b = nb;	
  }
}

public class inheritance_example {
  public static void main(String[] args) {
    Parent a = new Parent(3);  // define an object of class Parent
    Child b = new Child(1, 3);  // define an object of class Child
    // polymorphism: an object of type Parent refers to type Child
    Parent c = b; 
    Child d;
    if (c instanceof Child)  // check if c points to class Child
      d = (Child)c; // cast the object referred to by c, to type Child
  }
}
@


\subsection{Abstract Classes}

Abstract methods are functions that are defined in a class without an implementation. To specify that a method is abstract, prefix the method definition with the \texttt{abstract} keyword. A class that has one or more abstract methods is called an abstract class, and the prefix \texttt{abstract} must appear before the class definition. 

Since abstract classes may contain methods without an implementation it is illegal to define objects corresponding to abstract classes. If a subclass of an abstract class implements the abstract methods, the subclass is no longer abstract and the corresponding objects may be defined. 

\subsection{Access Modifiers} \label{sec:java:access}

Access modifiers determine the visibility of fields and methods to different software component. The following list describes three access modifiers, and the default modifier that applies when no access modifier is explicitly selected. 

\begin{description}
\item[public.] Public fields and methods are visible to all.
\item[private.] Private fields and methods are visible only to the class itself.
\item[protected.] Protected fields and methods are visible only to the class itself, its subclasses, and the package.
\item[default.] Protected fields and methods are visible only to the class and the package.
\end{description}

\section{The Object Class} \label{sec:java:object}

All classes in Java are implicitly inherited from the \texttt{Object} class, and share the methods defined in the \texttt{Object} class. Some of the methods of \texttt{Object} are listed below.

\begin{center}
\begin{tabular}{|l|l|}
\hline
Method name & Functionality \\ \hline
\texttt{equals} & \texttt{x.equals(y)} returns \texttt{true}  if the two objects are equal in value.\\
\texttt{hashCode} & \texttt{x.hashCode()} returns an integer value hashing the object \texttt{x}. \\ & The hash value is based on the content of the object and two \\ & objects that are equal (according to the \texttt{equals} method)  \\ & should get the same hash value.  \\
\texttt{toString} & \texttt{x.toString()}  returns a string describing the object \texttt{x}.\\
                  & It is used implicitly when an object is printed using\\ & \texttt{System.out.print}.\\
\texttt{clone} & \texttt{x.clone()} returns a new object that is a duplicate of \texttt{x}. \\ \hline 
\end{tabular}
\end{center}

Since these functions are defined for \texttt{Object}  - a class that is the superclass of all other classes, it may be desirable to overload some of these methods if their default behavior is inappropriate. For example, if \texttt{x} is an object whose fields are themselves objects, \texttt{clone()} will create a duplicate with a new set of fields that point to the same memory as the fields of the original objects. In other words, \texttt{clone} performs shallow copying, and fails to duplicate nested objects within the original object. A customized \texttt{clone} may be defined using function overloading to perform deep copying. 

\section{Interfaces}

An interface is a collection of method declarations (methods whose implementations are missing). A class implements the interface if it provides an implementation to the methods in the interface. We denote this by appending \texttt{implements interface\_name} after the class name in the class definition. All methods in an interface are by default \texttt{public} and should be defined in that way in the implementing class.

For example, the interface below contains the method \texttt{foo}. The class \texttt{A} implements that interface.

<<engine="Rcpp",eval=FALSE>>=
interface I {
  int foo();
}

class A implements I {
  int foo() {
    return(1);	
  }
}
@

A class can implement more than a single interface and each interface can be implemented by more than a single class. The interface mechanism may be used in conjunction with inheritance. 

\section{Generics} \label{sec:java:generics}

Java generics are very similar to templates in C++. See Section~\ref{sec:c:templates} for more details on C++ templates. A few important differences between C++ templates and Java generic appear below.

\begin{enumerate}
\item 	In Java there is no need to include the keyword \texttt{template} when defining a generic class. 	
\item The generic type may by omitted during the dynamic memory allocation of a generic object. For example in \texttt{ArrayList<String> books = new ArrayList<>()} we omit the generic type after the \texttt{new} statement. The omitted type is inferred automatically.
\item Generic parameter types cannot be primitive variables. For example, the objects \texttt{Double} and \texttt{Integer} should be used as generic parameters instead of the primitive variables \texttt{double} and \texttt{int} (see Section~\ref{sec:java:nonPrimitive} for more information on primitive types and their corresponding objects). 
\item A single method within a non-generic class can be defined as generic. The appropriate syntax is to prefix the method name with the angle bracket notation rather than to append it as in C++.
\end{enumerate}

For example, the code below defines a generic class in Java.

<<engine="Rcpp",eval=FALSE>>=
class point<T> {
  private T x;
  private T y;
  public T get_x() {
    return(x);
  } 
  public T get_y() {
    return(y);
  } 
  public void set_x(T nx) {
    x = nx;
  } 
  public void set_y(T ny) {
    y = ny;
  } 
  point() {}  // empty constructor
}

public class generic_example {
  public static void main(String[] args) {
    point<Double> p = new point<>();
    p.set_x(3.0);
    p.set_y(1.0);
    System.out.println("x: " + p.get_x() + " y: " + p.get_y());
  }	
}
@

Compiling and executing the program above gives the following output.

<<engine="Rcpp",eval=FALSE>>=
x: 3.0 y: 1.0
@

The code below defines a generic method.

<<engine="Rcpp",eval=FALSE>>=
class point {
  ...
  // definition of a generic method
  public static <T> T process_value(T x) {
  ...	
  }
  ...
}
 
public class generic_example2 {
  public static void main(String[] args) {
    ...
    // call generic method 
    point.<String>process_value("my_file.txt");  
    ...
  }	
}
@

\section{Collections}

Java collections are analogous to container classes in C++'s STL (see Section~\ref{sec:c:STL}). There are multiple generic classes that implement standard collection operations such as insertion, deletion, look-up, and iteration. The classes differ in the precise operation that they implement, and in the way the operations are implemented. For example, some classes are more efficient in insertion while other classes are more efficient in look-up. 

Some popular Java collection classes are listed in the table below. 
 
\paragraph{}

\begin{tabular}{|l|l|} \hline
Class & Description  \\ \hline \hline
\texttt{ArrayList} & Similar to a Java array, with the added \\
                   & capability of modifying its size as elements\\
                   & are added or deleted (similar to vector in C++ STL).\\
\texttt{LinkedList} & Ordered sequence that allows fast insertion and \\
                    & deletion at any location.\\
\texttt{HashSet} & Unordered collection that does not allow duplicates.\\
\texttt{TreeSet} & Ordered version of \texttt{HashSet}.\\
\texttt{PriorityQueue} & Ordered collection that allows fast removal of \\
                      & smallest element.\\
\texttt{HashMap} & Stores key-value pairs for fast retrieval based on key values. \\ 
\texttt{TreeMap} & Ordered version of \texttt{HashMap}. \\ \hline
\end{tabular}

\paragraph{}

The classes above map to data structures in a straightforward way. \texttt{ArrayList} corresponds to an array that has extra memory in case additional elements are inserted (the array is copied to a different location if additional size is needed). \texttt{ArrayList} provides random access (fast look-up at an arbitrary position of the array).

\texttt{LinkedList} is implemented as a doubly connected linked list and allows easy insertion and deletion at any point inside the sequence. It does not allow random access as it requires traversing the linked list until reaching the required position.

\texttt{HashSet} and \texttt{HashMap} are implemented as hash tables using linked lists for collision handling. They differ in that \texttt{HashMap} stores key-value pairs whereas \texttt{HashSet} stores only keys. Both classes do not allow multiple copies with the same keys and are unordered in the sense that they do not allow traversing the elements in order.  \texttt{HashSet} and \texttt{HashMap} provide fast look-up, insertion, and deletion as long as the hash function hashes the data with a uniform key distribution.

\texttt{PriorityQueue} is implemented as a heap. It allows fast removal of the smallest element. 

\texttt{TreeSet} is an ordered version of \texttt{HashSet} that allows traversing all elements in order. \texttt{TreeMap} is an ordered version of \texttt{HashMap} that allows traversing all elements in order. \texttt{TreeSet} and \texttt{TreeMap} are implemented using binary search trees rather than hash tables. 

The code below shows an example of using the \texttt{ArrayList} class.


<<engine="Rcpp",eval=FALSE>>=
import java.util.ArrayList;

public class ArrayList_example {
  public static void main(String[] args) {
    ArrayList<Double> al = new ArrayList<Double>();
    // insert three elements
    al.add(1.0);
    al.add(3.0);
    al.add(2.0);
    // traverse collection and print elements
    for (double d : al)
      System.out.print(d + " ");
    System.out.println("");
    // modify 2nd element
    al.set(1, 3.5);
    // print 2nd element (random access)
    System.out.println(al.get(1));
    // traverse collection and print elements
    for (double d : al)
      System.out.print(d + " ");
    System.out.println("");
  }	
}
@

Running the program above produces the following output.

<<engine="Rcpp",eval=FALSE>>=
## 1.0 3.0 2.0
## 3.5
## 1.0 3.5 2.0
@

The code below shows an example of using the \texttt{HashMap} class.

<<engine="Rcpp",eval=FALSE>>=
import java.util.HashMap;

public class HashMap_example {
  public static void main(String[] args) {
    HashMap<String,Double> hm = new HashMap<>();
    // insert three elements
    hm.put("John", 1.0);
    hm.put("Mary", 3.0);
    hm.put("Jane", 2.0);
    // print all entries
    System.out.println(hm);
    // remove an entry
    hm.remove("Jane");
    // print all entries
    System.out.println(hm);
    // Value lookup based on key
    System.out.println("John: " + hm.get("John"));
  }	
}
@

Running the program above produces the following output.

<<engine="Rcpp",eval=FALSE>>=
## {Jane=2.0, Mary=3.0, John=1.0}
## {Mary=3.0, John=1.0}
## John: 1.0
@

For more information refer to the online documentation or the textbooks in the next section. 

\section{Notes}

The first version of Java was released by Sun in 1996. The motivation behind the release was to create a new platform-independent language that is especially suited for web programming. Subsequent versions were released by Sun and later Oracle, which bought Sun, until the current version Java 8 (as of 2015). James Gosling, a former employee of Sun and later Oracle, is widely considered to be the father of the Java programming language. 

There are many good textbooks on Java. One example is the two volume set: \cite{Horstmann2012} (volume 1), which covers basic features, and \cite{Horstmann2013} (volume 2), which covers advanced features. The online application programming interface (API) at \newline \noindent \href{http://docs.oracle.com/javase/8/docs/api}{http://docs.oracle.com/javase/8/docs/api/} provides extensive Java documentation (replace 8 in the URL with a different Java version number if needed). The website \href{http://docs.oracle.com/javase/tutorial}{http://docs.oracle.com/javase/tutorial} contains links to many Java tutorials.