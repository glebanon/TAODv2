 \label{chap:Python}
 \section{Overview}

Python is a general purpose programming language that emphasizes object-oriented programming, extensibility, and code readability. Like R, Python's syntax makes it possible to express complicated programs in fewer lines of codes than C++ or Java. 

Python is most often used as an interpreted scripting language. Python code is typically stored in .py files. When the Python program executes, it compiles the Python code in the .py file into Python byte code that is stored in .pyc or .pyo files. The CPython interpreter program then executes the Python byte code. The interpreted nature of this process makes Python programs slower than the corresponding C or C++ implementations. Typically, Python programs are also slower than the corresponding Java programs but faster than the corresponding R programs. It is also possible to compile Python code into an executable file that is executed on a machine that does not have the CPython interpreter installed.  

Python is one of the most popular programming languages. It is used broadly in programming web applications, writing scripts that automate operating system commands, accessing databases, processing text data, and data analysis. An important feature is its extensibility, which has led to the development of many high quality extensions. Some of these extensions are extremely useful for data analysis, for example Numpy, Scipy, and Pandas.

Python can be run inside an interactive shell by typing \texttt{python} in the Linux or Mac terminal. Typing \texttt{exit()} terminates the interactive shell and returns to the terminal prompt. In interactive mode the programmer can enter commands and see their effects immediately, which accelerates the software development and data analysis processes. Many programmers prefer to use the IPython interactive shell instead of the standard Python interactive shell. An alternative way of running Python interactively is through the Eclipse plugin PyDev (\href{http://pydev.org}{http://pydev.org}), or by using a python IDE such as IDLE (\href{http://docs.python.org/2/library/idle.html}{http://docs.python.org/2/library/idle.html}) or Enthought's Canopy \\ (\href{https://www.enthought.com/products/canopy}{https://www.enthought.com/products/canopy}). Python modes are also available for the Emacs and Vim editors. 

A non-interactive programming process begins with writing the Python code and storing it in a .py file and then calling the python command with the appropriate file name argument, for example \texttt{python my\_prog.py}. If the line \texttt{\#!/usr/bin/python} appears at the top of a Python code file, the file can be executed by typing the file name  in the Linux or Mac terminal. This assumes that the Python program is placed in the \texttt{/usr/bin} directory and that the file containing the Python code has executable permissions (see Chapter \ref{chap:os} for more details on shells and file permissions).

Each line of Python code may hold several Python commands separated by a semi-colon (if the line contains a single command the semi-colon is optional). Text following a  \texttt{\#} symbol is considered a comment and is ignored by the Python program. 

As in other chapters, we prefix lines output by the program by \texttt{\#\#}. Doing so makes it easy to copy and paste code segments from electronic versions of this book into an IPython interactive shell or text file (the lines prefixed by \texttt{\#\#} will be ignored as comments and will not trigger an error). The code segment below demonstrates a short Python program followed by two lines of output generated by the Python program when the code is executed. We will describe the print function in more detail later on in this chapter.

<<types1, engine="python">>=
# this is a comment
# assign values 1 and 2 to variables x, y
x = 1
y = 2 
# print the values that the two variables refer to
print("x refers to: " + str(x))
print("y refers to: " + str(y)) 
@

The Python programs in this book are tested in Python 2.7, the stable Python implementation at the time of writing (2015). A new branch of Python, Python 3.X, offers several new features, but does not have full backward compatibility\footnote{Most of the important data analysis extensions have been ported from Python 2.X to 3.X, but not all.} to Python 2.X. Nevertheless, the code in this book should run as expected in Python 3.X as well. 

%-------------------------------------------------------
\section{Types, Variables, and Scope}

Variable names in python are untyped and refer to typed objects in memory. This means that a variable name may be reassigned to refer to an object of a different type, but the type of objects in memory is fixed. 

<<types2, engine="python">>=
# variables are dynamically typed
x = 3
x = "three"  # ok in Python
@

In an assignment such as \texttt{x = y} the object referred to by \texttt{y} is not copied - instead the assignment makes \texttt{x} and \texttt{y} refer to the same object. Thus, there may be more than a single variable referring to the same object in memory.

<<types3, engine="python">>=
x = [1, 2, 3]  # define a list
y = x  # both x and y refer to the same list
y.append(4)  # appending to y impacts x as well
print(x)
@

In Python, every number, string, data structure, function, class, etc., are objects. As in C++ and Java, Python objects have member variables and member functions that can be accessed using the period operator. 

<<types4, engine="python">>=
s = "three" 
# call upper, a member function of the string object
t = s.upper() 
print(t)
@

A Python module is a .py source code that is executed when we call \texttt{import} followed by the module file name (without the .py suffix). In many cases, modules consist of definitions of variables, functions, and classes, rather than code outside of such enviornments. When importing such modules, the definitions in the module become available for usage, but no additional side effect is executed during the \texttt{import} command.

For example, suppose we have a module file \texttt{my\_vars.py} containing the following code.

<<types41, engine="python",eval=FALSE>>=
LENGTH = 24
WIDTH = 48
@

The definitions in this file can be accessed in a different file using the appropriate import command.

<<types42a, engine="python",eval=FALSE>>=
import my_vars
# accessing variables in my_vars module
area = my_vars.LENGTH * my_vars.WIDTH 
@

The command \texttt{import module\_name as Y} makes the definition in \texttt{module\_name} available when prefixed by \texttt{Y} and a period instead of the module name (\texttt{Y} may be replaced by other strings).

<<types42z, engine="python",eval=FALSE>>=
import my_vars as mv
area = mv.LENGTH * mv.WIDTH 
@

Alternatively, the statement \texttt{from module\_name import X} makes a definition \texttt{X} in the module \texttt{module\_name.py} accessible without a need for a prefix (\texttt{X} may be replaced by any definition in the module). 

<<types42g, engine="python",eval=FALSE>>=
from my_vars import LENGTH, WIDTH
area = LENGTH * WIDTH  
@

Replacing \texttt{X} with the wildcard \texttt{*} makes all the definitions available for use without a need for a prefix. 

<<types42h, engine="python",eval=FALSE>>=
from my_vars import *
area = LENGTH * WIDTH  
@

The function \texttt{dir()} displays all currently defined names (variables, functions, modules). If supplied with an argument, \texttt{dir(X)}, it shows all names defined in the module \texttt{X}. The function \texttt{help(X)} displays information about the function, class, or module \texttt{X}.

Shell commands can be executed from within Python using the function \texttt{system("shell command")}, which is defined in the module \texttt{os}.

<<types42bd, engine="python",eval=FALSE>>=
import os
os.system("ls -al")  # call shell command ls -al
@

A newer alternative to \texttt{os.system} that provides much more flexible functionality is the \texttt{call} function, which is defined in the \texttt{subprocess} module. Subprocess can be used to spawn new processes, pipes and input and output redirection. 

<<types42e, engine="python",eval=FALSE>>=
import subprocess as sp
sp.call(["ls", "-al"])
@

The function \texttt{os.chdir(path)} changes the current directory inside Python code. The function \texttt{os.getcwd()} returns the current directory.

%-------------------------------------------------------
\section{Scalar Data Types and Operators}

Python's scalar data types are similar to the corresponding types in C++ and Java. A \texttt{bool} type holds \texttt{True} or \texttt{False} values. An \texttt{int} type holds integers and a \texttt{float} holds floating point number values. Large \texttt{int} values are automatically converted to a \texttt{long} type, which represents potentially large integers with arbitrary precision. The \texttt{str} type holds strings. The type \texttt{None} represents ``null'' value.

In some cases, objects of a particular type can be converted or cast to objects of a different type. Such casting tries to match the value in the new type to the value in the old type. Casting an object to a new type requires calling a function whose name is identical to the target type. In some cases casting fails with an error, for example casting a string object into an integer type.

<<types42c, engine="python">>=
a = 42
b = float(a)
c = str(a)
d = bool(a)
print("a: " + str(a))
print("b: " + str(b))
print("c: " + c)
print("d: " + str(d))
@


Python operators are similar to operators in C++ and Java. However, Boolean operators in Python are usually expressed using keywords, for example \texttt{and}, \texttt{or}, and \texttt{not}. 

<<types43q, engine="python">>=
x = True
y = False
print(x and y)
print(x or y)
print(not x)
@

Table~\ref{tab:python:operator} lists a few cases where Python considers operators differently from Java or C++.


\begin{figure}
	\centering
\begin{tabular}{|l|l|}
\hline
Python Operator & Description\\ \hline \hline
\texttt{x ** y}& \texttt{x} raised to the power \texttt{y}\\ \hline
\texttt{x // y}& divide \texttt{x} by \texttt{y} and omit remainder\\ \hline
\texttt{x and y}& \texttt{True} if \texttt{x} and \texttt{y} are \texttt{True}\\ \hline
\texttt{x or y}& \texttt{True} if \texttt{x} or \texttt{y} are \texttt{True} \\ \hline
\texttt{not x}& \texttt{True} if \texttt{x} is \texttt{False}\\ \hline
\texttt{x is y}& \texttt{True} if \texttt{x} and \texttt{y} refer to the same object\\ \hline
\texttt{x is not y}& \texttt{True} if \texttt{x} and \texttt{y} do not refer to the same object\\ \hline \texttt{x == y}& \texttt{True} if \texttt{x} and \texttt{y} refer to objects holding the same value \\ 
\hline
\end{tabular}
\caption{Python operators that differ from the standard C++ and Java syntax.}
\label{tab:python:operator}
\end{figure}



Strings in Python can be denoted using single or double quotes. Strings that span several lines can be denoted using three consecutive single or double quotes. Prefixing the operator \texttt{r'} before a string instructs Python to avoid substituting escape characters in the string (such as the newline escape character backslash followed by n).

<<types43, engine="python",eval=TRUE>>=
s = ''' this is a string
that spans
multiple lines'''
print('\n line')
print(r'\n line')
@

Below are a few string properties in Python.

\begin{itemize}
\item Python strings are immutable and thus cannot be modified after they are created. It is possible to create a new string that is a modification of an existing string. \item Specific characters in a string can be referred to using the square bracket index notation (indices in Python start from 0). 
\item Many Python objects can be converted to a string using the \texttt{str} function. 
\item Two python strings can be concatenated using the \texttt{+} operator. 

\item The string object includes many member functions that are useful for manipulating strings. A few examples are listed in the example below.

<<types44, engine="python">>=
s = "Python"
print(s[2])  # print third element of object s
print(s + str(123))  # concatenate s with the string "123"
print(s.replace('P', 'p'))  # replace P in object s with p
@

\item 
It is convenient to form strings by embedding numeric variables into a string template. A template is a string that contains markers denoted by \texttt{\%f} (for float), \texttt{\%d} (for integer), or \texttt{\%s} (for string). When the template is paired with a list of variables using the \texttt{\%} operator, the variables are embedded in the corresponding markers. This technique is similar to the \texttt{printf} function in C++. 

<<types45, engine="python">>=
s = "two"
t = 2
w = 2.0
print("%s is the string corresponding to 2" % s)
print("%d is the integer representation of %f" % (t, w))
@

\end{itemize}

\subsection{Duck Typing} \label{sec:python:duck}

In Java and C++ the suitability of an operation for an object is determined by the object type. For example, a function \texttt{foo(x)} will be able to operate on its argument based on whether \texttt{x} is of a suitable type specified in the function definition. A C++ function \texttt{int foo(float x)} will only work on a \texttt{float} argument.

In duck typing, the constraints are not specified in the code in the same sense. Rather, the interpreter tries to execute the code and if it cannot, a run-time crash will occur. For example, a function will take an argument of any type and tries to execute the code. Duck typing is called duck typing after the phrase ``if it walks like a duck and quacks like a duck, it is a duck''.

Below is an example where the function \texttt{foo} accepts any objects that can execute the two functions \texttt{quack} and \texttt{walk} (rather than be constrained to a specific class). As a result, we can call it with both a \texttt{Duck} object and a \texttt{Fox} object that imitates a \texttt{Duck} in that it can execute the functions \texttt{quack} and \texttt{walk}.

<<engine="python">>=
class Duck:
  def quack(self):
    print("Quack")
  def walk(self):
    print("Shuffle")

class Fox:
  def quack(self):
    print("Quackkkkk")
  def walk(self):
    print("Shuffffle")
  def kill(self):
    print("Yum!")

def foo(x):
  x.quack()
  x.walk()

donald = Duck()
swiper = Fox()
foo(donald)
foo(swiper)
@

There is some similarity between duck typing and interfaces in Java. Duck typing is less constrained since it is not required to specify that a particular interface is being implemented. In addition duck typing can implement only a part of an interface, and if only that part is called then the program will proceed to exectution.

One disadvantage of duck typing is that it leads to less compile time errors and more run-time errors. Run time errors are generally considered undesirable as they are hard to prevent and debug. 


%-------------------------------------------------------
\section{Compound Data Types}

Python's most popular compound data types are tuples, lists, dictionaries, and sets. We describe these types below. Section~\ref{sec:python:numpy} describes additional compound data types.

%-------------------------------------------------------
\subsection{Tuples}

A tuple is an immutable sequence of objects of potentially different types. Each object can be referred to using the square bracket index notation. Tuples are defined using parenthesis or the keyword \texttt{tuple}. 

<<types46, engine="python",eval=FALSE>>=
a = (1, 2)  # tuple of two integers
a[0] = 3  # error: modifying an immutable tuple after its creation
@

<<types46a, engine="python">>=
a = (1, 2)  # tuple of two integers
b = (1, "one")  # tuple of integer and string
c = (a, b)  # tuple containing two tuples
print(b[1])  # print the second element of b
print(c[0])  # print the first element of c
@

It is possible to unpack a tuple into individual variables as follows.

<<types46b, engine="python">>=
tup = (1, 2, 3)  # tuple of three integers
(a, b, c) = tup  # copy first element of tup to a, second to b, etc.
print(a)
print(b)
print(c)
@

Nested tuples can also be unpacked as follows.

<<types46c, engine="python">>=
tup = (1, (2, 3))  # tuple containing an integer and a tuple
# copy the first element of tup to a, second to (b, c)
(a, (b, c)) = tup  
print(a)
print(b)
print(c)
@


\subsection{Lists}

Lists are similar to tuples, but are mutable, and are defined using square brackets.

<<types46d, engine="python">>=
l1 = [1,2,3]  # list containing three integers
l2 = [l1, "1-3"]  # list containing a list and a string
l2.append(4)  # modify existing list by appending an element
print(l1)
print(l2)
@

Existing list elements can be removed and new elements can be inserted at arbitrary position, but these operations are often time consuming for long lists. Lists can also be easily sorted and combined. The method \texttt{sort(X)} sorts a list in-place (overwrites the object calling the method) and the method \texttt{sorted} returns a new list that is a sorted version of the object calling the method.

<<types46e, engine="python">>=
l = [1,2,3] 
l.insert(1,100)  # insert 100 before index 1
l.remove(2)  # remove first occurrence of 2
print(l)
l.sort()  # sort list
print(l)
l.extend([20,21,23])  # extend list with an additional list
print(l)
@

The statement \texttt{del} deletes a list element by index and the function \texttt{len} returns the length of the list. The functions \texttt{append}, \texttt{insert}, and \texttt{remove} appends an element, inserts an element, and removes an element (by value). 

<<types46h, engine="python">>=
l = [1,2,3] 
del l[1]
print(l)
@

The function \texttt{range} creates a list of evenly spaced integers. The first argument denotes the starting value, the second argument denotes the end position plus one, and the third argument denotes the step size (defaults to 1).

<<types46ee, engine="python">>=
print(range(0, 10, 2))
print(range(0, 10))
@


\subsection{Slicing}

Slicing refers to accessing a subset of a list, tuple, or string using a sequence of integers representing the corresponding indices. The sequence of integers is represented using the notation \texttt{a:b:c} where \texttt{a} denotes the first selected position (default is 0), \texttt{b} the integer following the last selected index (default is last index plus 1), and \texttt{c} represents a potential skip value (default is 1). Some or all of \texttt{a}, \texttt{b}, or \texttt{c} may be omitted (if \texttt{c} is omitted the second colon may be left out). 

<<types47, engine="python">>=
l = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(l[:])  # starting index (0) to end index (9)
print(l[3:])  # index 3 to end (9)
print(l[:3])  # index 0 to 2
print(l[0:10:2])  # index 0 to 9, skipping every other element
@

Negative values of \texttt{c} represent progression from the end towards the beginning and negative values of \texttt{a}, \texttt{b} represent offset from the end (in the case of \texttt{a}) or the beginning (in the case of \texttt{b}).

<<types47b, engine="python">>=
l = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(l[::-1])  # start index (0) to end (9) - backwards
print(l[-3:])  # index 3 from the end (7) to the end (9)
@

The function \texttt{zip} pairs up elements from a number of lists or tuples to create a list of tuples.

<<types47c, engine="python">>=
l1 = [1, 2, 3]
l2 = ["one", "two", "three"]
print(zip(l1, l2))
@

\subsection{Sets}

A set is an unordered collection of unique immutable objects. A set can be defined using curly braces, with objects separated by commas. 

<<types48g, engine="python">>=
# duplicity in sets is ignored
s = {1, 2, 3, 2}
print(s)
@

The following code demonstrates the set operations of union $A\cup B$ , intersection $A\cap B$, and set-difference $A\setminus B$, and the set relations $A\cap B=\emptyset$ (disjoint), $A\subset B$ (subset), and $A \supset B$ (superset).  Appendix A of Volume 1 contains a description of these operations.

<<types48h, engine="python">>=
s1 = set([1, 2, 3])
s2 = set([2, 3, 4])
print(s1 | s2)  # union
print(s1 & s2)  # intersection
print(s1 - s2)  # set-difference
print(s1.isdisjoint(s2), s1.issubset(s2), s1.issuperset(s2))
@

\subsection{Dictionaries}

A dictionary is an unordered, mutable compound data type representing a set of (key, value) pairs, where each key may appear at most one time. Each (key, value) pair may be thought of as a mapping from a key to a value, and consequentially the entire dictionary can be thought of as a function mapping keys to values. 

Dictionaries are denoted using curly braces with each key-value pair separated by a colon, and multiple key-value pairs separated by commas. Dictionaries are mutable and thus additional key-value pairs may be added or removed after the dictionary is created.

The example below creates a dictionary with two key-value pairs and then prints all keys and all values.

<<types48ab, engine="python">>=
# create a dict with two key-value pairs: ("a",1) and ("b",(1,2,3))
d = {'a' : 1, 'b' : [1, 2, 3]}  
print(d.keys())  # print all keys
print(d.values())  # print all values
@


The primary use of a dictionary is in retrieving a value associated with a specific key. The example below does that, and it then checks whether a specific key exists in the dictionary.

<<types48, engine="python">>=
# create a dict with two key-value pairs
d = {'a' : 1, 'b' : [1, 2, 3]}  
print(d['a'])  # retrieve value corresponding to key "a"
print('c' in d)  # check if "c" is a key in dict d
@

In the example below we create a dictionary object and then add a new key-value pair and remove an existing key-value pair. We then print the dictionary as a sequence of key-value pairs.

<<types48b, engine="python">>=
# create a dictionary with two key-value pairs
d = {'a' : 1, 'b' : [1, 2, 3]}  
d['c'] = "?"  # add the key value pair ("c", "?")
del d['a']  # remove key-value pair corresponding to key "a"
print(d)  # print dictionary 
@

Since dictionary are unordered, iterating over the  key-value pairs is not guaranteed to follow the order of insertion or the alphabetic order over the keys.

It is easy to create dictionaries from two lists, one containing keys and the other containing values using the function \texttt{zip} that creates a list of tuples from multiple lists.

<<types48d, engine="python">>=
l1 = [1,2,3]
l2 = ["one", "two", "three"]
d = dict(zip(l1, l2))
print(d)
@

The following example iterates over all keys in a dictionary object. We will see the details of the \texttt{for} control flow structure in the next section.

<<types48e, engine="python">>=
d = {"a" : 1, "b" : 2}  
# iterate over all keys in d
for key in d:  
  print(key, d[key])
@
	
In addition to the requirement that each key may appear at most once, keys are required to be hashable (the \texttt{hash} function must be able to take the key as an argument) and thus have to be immutable. Examples of hashable immutable objects are integers, floats, strings, and tuples. Lists and dictionaries are mutable and therefore cannot serve as keys in a dictionary.

The code example below prints the hash values of a string and a tuple of integers. 

<<types48f, engine="python">>=
print(hash("abc"))  
print(hash((1, 2, 3)))
@

%-------------------------------------------------------
\section{Control Flow}

Python uses white spaces (tabs or spaces) to structure code instead of braces as in Java, C++, and R. A colon denotes the start of an indented code block, after which all lines must be indented by the same amount. A return to the previous indentation signals that the block corresponding to the indented block is ending and a new block begins.

\subsection{If-Else}

If-else blocks use the following structure. Note the lack of curly braces and that the indentation indicates where each \texttt{if}, \texttt{elif} (else-if) or \texttt{else} clause end.

<<control0, engine="python">>=
x = 3
if x > 0:  # if block
  print("x is positive")
  sign = 1
elif x == 0:  # elif (else-if) block
  print("x equals zero")
  sign = 0
else:  # else block
  print("x is negative")
  sign = -1
print(sign)  # new block
@

\subsection{For Loops}

Python for loops typically take the following form, where a variable iterates over all element within a tuple, list, dictionary, or a different compound data type.

<<control1, engine="python">>=
L = [1, 2, 3, -4]
total = 0
for x in L:  # start of for block
  total = total + x
print(total)  # new block
@

We can keep track of the iteration number using the \texttt{enumerate} function as follows.

<<control1a, engine="python">>=
L = [1, 2, 3, -4]
total = 0
for (i,x) in enumerate(L): 
  print("this is iteration %d" % i)
  total = total + x
print(total)
@

The example below shows a combination of an outer for-loop block and an inner if-else clause. It computes the sum of absolute values of the elements of a list.

<<control1c, engine="python">>=
L = [1, 2, 3, -4]
abs_sum = 0
count = 0
for x in L: 
  count = count + 1
  if x > 0:
    abs_sum = abs_sum + x
  else:
    abs_sum = abs_sum - x
print("sum of absolute values: %d" % abs_sum)
print("number of elements in list: %d" % count)
@

%--------------------------------------------------
\section{Functions}

Functions in Python are similar to functions in C++, Java, and R. When a function is called, execution transfers to the function code, and after the function terminates execution returns to the next line after the function call. As in the case of \texttt{if} and \texttt{for} blocks, the block of the function definition code is denoted using a colon and indentation in the following lines.

The calling enviornment may pass arguments to the function, which are tied to the function parameters and may be used in the function code. The arguments may be tied to the parameters by their position in the sequence of passed arguments, or by using the parameter name. Parameters that are omitted receive default values. The function terminates when encountering a \texttt{return} statement or when the end of the block is reached (in which case \texttt{None} is returned).

The code below defines a function \texttt{mypower}, which raises the first parameter \texttt{base} to the power of the second argument \texttt{exp}. Note the default values of 10 and 2 that will be used if the corresponding arguments are omitted. After the function definition, the code below calls the function multiple times with different arguments.

<<funcs1, engine="python">>=
def mypower(base = 10, exp = 2):
  res = base ** exp  # raise base to the power exp
  return(res)
print("mypower(2, 3): " + str(mypower(2, 3)))  
print("mypower(exp = 3, base = 2): " + str(mypower(exp = 3, base = 2)))  
print("mypower(): " + str(mypower()))
print("mypower(5): " + str(mypower(5)))
print("mypower(exp=3): " + str(mypower(exp = 3)))
@

In the first case above, no parameter names are mentioned and so the first argument 2 is tied to the first parameter \texttt{base} and the second argument 3 is tied to the second parameter \texttt{exp}. In the second case, parameter names are supplied and thus the order in which the arguments appear is irrelevant. In the third case, arguments are omitted and the default parameter values are used. In the fourth case a single argument is supplied without a name and that value is tied to the first argument \texttt{base} (the second argument \texttt{exp} receives default value). In the last case a single argument is passed and is tied  \texttt{exp} with the other parameter \texttt{base} receiving the default value of 10.

As in other languages, variables defined inside functions are local to the functions and thus not accessible from outside of the function. An exception to this rule are global variables that are defined by prefixing the variable name with the keyword \texttt{global}.

A function can return multiple objects by returning a tuple containing multiple objects. The tuple can then by easily unpacked to separate variables in the calling environment.

<<funcs2, engine="python">>=
def foo(x, y):
  return((x + y, x - y))
(a,b) = foo(1, 2)  # unpack the returned tuple into a and b
print(a)
print(b)
@

An alternative way to return multiple objects is to return a dictionary containing the returned objects as values and their descriptions or names as the corresponding keys.

\subsection{Anonymous Functions}

An anonymous function is similar to a regular function with the exception that it does not have a name. It is created using the \texttt{lambda} keyword and it is typically used when functions expect arguments that are functions. In this case, the calling environment can define an anonymous function and pass it on as an argument to the function. There is no need to name the function since it will never be used again (outside of it being passed as an argument to another function). The code below contains a simple example.
 
<<funcs3, engine="python">>=
# foo(x, f) expects two arguments: a number x and
# a function f that is applied to x
def foo(x, f):
  return(f(x))
# calling foo with 3 and f(z) = z + 1
print(foo(3, lambda z : z + 1))
# calling foo with 3 and f(z) = 2z^2
print(foo(3, lambda z : 2*(z**2)))
@

%-------------------------------------------------------
\section{Classes}

As in Java and C++, Python classes contain fields (variables) and methods (functions) and allow inheritence. We illustrate the concept below using a simple example of a class representing a point in a two dimensional coordinate space. 

<<engine="python">>=
class Point(object):
  def __init__(self, x=0, y=0):
    self.x = x
    self.y = y
  def __del__(self):
    print ("destructing a point object")
  def displayPoint(self):
    print "x: %f, y: %f" % (self.x, self.y)

p1 = Point(3, 4)
p2 = Point(1, 2)
p1.displayPoint()
p2.displayPoint()
@

The second print statement above uses a synax similar to the \texttt{printf} syntax in C and C++. In Python 3.X this syntax does not work and \texttt{print} is forced to use the function specific format using parenthesis, for example \texttt{print(\"x: \", self.x)}.


The class methods definitions include a list of function arguments, the first of which is \texttt{self}, that does not need to be passed when the method is called. For example, the initialization method above has three arguments \texttt{self, x, y}, but when a new object is instantiated only two arguments are used. Inside a class method definition we can refer to a field of the current object using \texttt{self.var\_name}. Outside of the method definition, fields and methods are called by prefxing the field or method name by the variable name followed by a period. 

The methods \texttt{\_\_init\_\_} and \texttt{\_\_del\_\_} are the initialization method and destructor method that are called when an object is instantiated or when an object is destroyed by the garbage collection mehcanism. Above, the initialization method is called with two arguments that are set by default to zero if an explicit value is not passed to the method.

The point class above has fields \texttt{x} and \texttt{y}, but they are not included in the class definition explicitly. In Python fields that are explicitly defined in the class definitions are class fields (similar to static fields). This means that all instantiated objects of the class share the same value. To refer to such class fields, prefix the field name with the class name followed by a period. The example below shows a class having fields \texttt{x} and \texttt{y} and a class field \texttt{num\_points} tracking the number of existing objects, and a \texttt{\_\_doc\_\_} class field holding the documentation string appearing after the class definition (see Section~\ref{sec:tools:docstrings} for more information on such documentation strings).

<<engine="python">>=
class Point(object):
  "point in a two dimensional coordinate space"
  numPoints = 0
  def __init__(self, x, y):
    Point.numPoints += 1 
    self.x = x
    self.y = y
  def __del__(self):
    Point.numPoints -= 1
    print "destructing a point object"
    print "now there are %d points left" % Point.numPoints
  def displayPoint(self):
    print "x: %f, y: %f" % (self.x, self.y)

print(Point.__doc__)
p1 = Point(3, 4)
p2 = Point(1, 2)
p1.displayPoint()
p2.displayPoint()
print "number of objects: %d" % Point.numPoints
@

Python does not enforce private access control as does Java or C++, but instead programmers can prefix fields and methods by a single underscore that by convention implies the field or method should not be accessed by external code. Prefixing a field or method by a double underscore is a similar solution to a single underscore but stronger as it executes name-mangling: accessing the field or method can only be done by prefixing the stated name with an underscore followed by the class name.

Encapsulation as in C++ and Java can still be accomplilshed by referring to fields using getter and setter functions instead or directly accessing the variables. This can be done using the functions \texttt{getattr(object, field)} and \texttt{setattr(object, field, value)}. 

\subsection{Inheritance}

Class inheritance in Python is indicated by including the base class in parenthesis after the class name. Fields and methods belonging to the base class can still be referred to in the sub-class. Fields and methods that are added to the sub-class but do not exist in the base class represent additional functionality. A sub-class can also reimplement a method that is already defined in the base class. This allows the sub-class to override the base-class functionality with new functionality that is customized ot the sub-class. 

We demonstrate this concept by defining \texttt{namedPoint}, a class derived from the above \texttt{Point} class. The class \texttt{Point} is derived from the generic \texttt{object} class, indicated by the expression below \texttt{class Point(object)} in the class definition. Similarly, \texttt{NamedPoint} is derived from \texttt{Point}, indicated by the expression \texttt{class NamedPoint(Point)}. Note that the constructor of \texttt{NamedPoint} calls the base class constructor followed by setting the name filed.

<<engine="python">>=
class Point(object):
  def __init__(self, x, y):
    self.x = x
    self.y = y
  def displayPoint(self):
    print "x: %f, y: %f" % (self.x, self.y)

class NamedPoint(Point):
  def __init__(self, x, y, name):
    # call superclass constructor
    super(NamedPoint, self).__init__(x, y)
    self.name = name  
  def display_point(self):
    print "x: %f, y: %f, name: %s" % (self.x, self.y, self.name)

np = NamedPoint(3, 4, "lower point")
np.display_point()
@

Note that in the example above, the \texttt{\_\_init\_\_} superclass was overriden by a new definition of \texttt{\_\_init\_\_} in the sub-class. Such overriding can be done for other methods as well. The Python 2.7 syntax above \texttt{super(NamedPoint, self).\_\_init\_\_(x, y)} that refers to the super-class initializer (rather than the sub-class initializer) can be replaced in Python 3.X to the following simpler syntax: \texttt{super().\_\_init\_\_(x,y)}.

Python also supports polymorphism in the sense that it performs dynamic time bindings. For example, if we call a method \texttt{foo} that is implemented differently by multiple subblasses, the interpreter will call the right method based on the specific subclass that the object is instantiating. 

In fact, Python has a stronger form of polymorphism than Java or C++ due to its duck typing (see Section~\ref{sec:python:duck}). The correct method will be called regardless of the inheritance hierarchy (assuming the object provides the method). As a result polymorphism and inheritance become somewhat less important in Python than in C++ and Java.

%-------------------------------------------------------
\section{IPython}

The traditional programming process has two stages: (a) writing code in one or more files, and (b) executing the code. This process is repeated as mistakes are found or additional features are added. In contrast, an interactive programming process consists of simultaneously writing and executing lines of code in an interactive shell. In many data analysis scenarios interactive programming is more effective than the traditional programming process. After the code has been fully developed using the interactive programming process, the code may be saved to a file and executed in a non-interactive manner.

IPython is an enhanced interactive environment that is more convenient than Python's default interactive environment. IPython can be installed separately and executed by typing \texttt{ipython} in the Linux or Mac terminal, or as a part of a software bundle (for example Enthought's Canopy). The website  \href{http://ipython.org}{http://ipython.org} contains documentation and installation instructions.

IPyhon features the following important improvements over the standard interactive environment. 

\begin{enumerate}
\item Pressing the tab key auto-completes variable names and function names. 
\item Copying code segments and pasting them in the IPython environment often works better than in the standard Python interactive environment.
\item Prefixing or postfixing a variable or function with \texttt{?} displays useful information. A double question mark \texttt{??} displays additional information.
\item Linux commands may be executed from the IPython prompt by prefixing them with \texttt{!}. The output of the shell command is displayed in the IPython environment. The prefix \texttt{!} may be omitted for some popular shell commands such as \texttt{ls}, \texttt{pwd}, \texttt{cd} commands.
\item IPython enables logging command history and searching previous commands using the Readline tool. For example, typing control-R followed by a string finds the last command containing that string. See \\ \href{http://cnswww.cns.cwru.edu/php/chet/readline/rltop.html}{http://cnswww.cns.cwru.edu/php/chet/readline/rltop.html} for more information. 
\item IPython has better support for displaying graphic windows and interacting with them.
\item IPython offers interactive debugging and profiling capabilities.  
\item IPython has some additional commands, typically prefixed by \texttt{\%}. For example, the command \texttt{\%run foo.py} runs the Python source code file \texttt{foo.py} in the IPython interactive environment and the commands \texttt{\%who} and \texttt{\%whos} display the variables currently defined in the IPython environment (\texttt{\%whos} also displays the object that the variables refer to).
\end{enumerate}

We describe below how to debug and profile using IPython.

\subsection{Debugging}

IPython enhances Python's standard debugger pdb with tab completion and syntax highlighting, and it displays better context information. One way to execute the IPython debugger is by typing \texttt{\%debug} right after an error has occurred. In this case, the IPython debugger starts in the precise position where the error exception was raised. Another way to enter the debugger is by typing the command \texttt{\%run -d foo.py}, which starts the debugger before executing any line of \texttt{foo.py}. 

Inside the debugger, the command \texttt{n} (next) executes the current line and advances to the next line, the command \texttt{s} steps into a function call, the command \texttt{c} continues execution from the current position, and the command \texttt{b filename.py:line\_number} sets a breakpoint at a specific line of the corresponding source file. 

An alternative to using IPython's debugger is using Eclipse and the PyDev plugin (\href{http://pydev.org}{http://pydev.org}), which provide interactive debugging through the Eclipse IDE.

\subsection{Profiling}

IPython has a number of convenient tools for measuring execution time and more generally profiling code. The IPython command \texttt{\%time statement} runs the corresponding Python statement and reports execution time. The command \texttt{\%timeit statement} is similar, but it runs the statement multiple times and reports running time statistics. The command \texttt{\%time} is appropriate for measuring Python statements that take a significant amount of time to completion, while \texttt{\%timeit} is appropriate for measuring Python statements that execute in a short amount of time.

The Python profiler can be executed by calling Python from the Linux or Mac terminal with a .py file as an argument and the following flags. The profiler generates a report profiling the execution of the code in the corresponding python file.

<<prof1, engine="python",eval=FALSE>>=
python -m cProfile -s cumulative file_name.py
@

A similar report can be generated by typing the following command inside IPython: \texttt{\%run -p -s cumulative file\_name.py}. The IPython command \texttt{\%prun -s cumulative foo()} is similar, but it profiles arbitrary statements or functions rather than entire Python source files (in this case it profiles the execution of the function \texttt{foo}).

IPython features additional profiling tools including a line profiler that shows how much time was spent on different lines of code (\texttt{lprun} command) and memory profiling (\texttt{mprun} and \texttt{memti} commands). Consult the online documentation for additional information on these tools.

%-------------------------------------------------------
\section{Numpy, Scipy, and Pandas} \label{sec:python:numpy}

Python has a large collection of modules that can be imported, some of which are part of the Python standard library and are installed by default. Third party modules in the Python Package Index (PyPI) can be installed using the \texttt{pip} command\footnote{To install the pip tool download it from the internet or type \texttt{sudo python -m ensurepip} in Python 3.4 or above.}. For example, to install a third party module \texttt{X} in PyPI call \texttt{pip install X}. In this section we cover three important modules for data analysis: numpy, scipy, and pandas. Chapter~\ref{chapter:graphics} describes another module, matplotlib, for generating graphs from data.

Numpy is a Python package that provides (a) a data type \texttt{ndarray} for multidimensional arrays, (b) tools for vector, matrix, and array arithmetic operators over \texttt{ndarray} objects, (c) linear algebra and random number generation functionality, and (d) tools for reading from files and writing to files \texttt{ndarray} objects. 

Scipy is a Python package that provides optimization algorithms, mathematical functions, signal processing techniques, and sparse matrix objects. 

Pandas is a Python package that contains an implementation of an R-like dataframe object and includes a variety of functionality for manipulating dataframes. We give a brief overview of the three packages below. 	

\subsection{Ndarray Objects}

An ndarry is a multidimensional array that generalizes the one dimensional list into higher dimensions. Numpy and other Python packages feature a wide variety of functions that can operate on ndarrays. Ndarrays have a \texttt{shape} variable that is a list of its dimensions (for example (2,3) corresponds to a $2\times 3$ matrix) and a \texttt{dtype} variable that corresponds to the type of data that it holds. Since an ndarray is an object we can refer to its variables and methods using the period operator. 

The code example below shows how to define a 2x3 ndarray containing numbers, printing it, and casting its values to integers. 

<<ndarray1, engine="python">>=
import numpy as np
# create 2x3 ndarray of floats from a list of lists
L = np.array([[1, 2, 3], [4, 5, 6]], dtype = "float32")
print("L.shape: " + str(L.shape))
print("L.dtype: " + str(L.dtype))
print("L: \n" + str(L))
L.dtype = np.int32  # cast the ndarray from float to int
L.astype(np.int32)  # another way to achieve the same casting
@

The code below defines three ndarrays and prints them.

<<ndarray2, engine="python">>=
import numpy as np
a1 = np.zeros((2,3))  # create a 2x3 ndarray of zeros
a2 = np.identity(3)  # the 3x3 identity matrix
a3 = np.ones((2,3,2))  # create a 2x3x4 ndarray of ones
print("a1: \n" + str(a1))
print("a2: \n" + str(a2))
print("a3: \n" + str(a3))
@

Arithmetic operations between ndarrays typically operate element-wise. Operations between an ndarray and a scalar repeats the scalar operation across all elements of the ndarray.

The code below defines two ndarrays, multiplies the first one by 2, and then adds them.

<<ndarray3, engine="python">>=
import numpy as np
a1 = np.identity(3)
a2 = np.ones((3,3))
print("2 * a1: \n" + str(2 * a1))
print("a1 + a2: \n" + str(a1 + a2))
@

There are two convenient ways to refer to a portion of an ndarray: (a) using the sublist or slicing notation and (b) using a logical condition that characterizes the selected indices. Recall that the sublist notation $a$:$b$ starts from index $a$ and continues until index $b-1$ (indices count starts from 0). This works on both the right hand side and the left hand side of the assignment operator. 

A example showing the sublist notation in the 1-d case appears below.

<<ndarray5, engine="python">>=
import numpy as np
a = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8]) 
print("a[:]: " + str(a[:]))
print("a[3]: " + str(a[3]))
print("a[3:6]: " + str(a[3:6]))
a[3:6] = -1
print("modified a: " + str(a))
@

The example below shows the logical condition in 1-d.

<<ndarray6, engine="python">>=
import numpy as np
a = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8])
# create an bool ndarray of True/False
print("a < 3: " + str(a < 3))  
# refer to all elements that are lower than 3
print("a[a < 3]: " + str(a[a < 3]))  
a[a < 3] = 0  # replace elements lower than 3 by 0
print("modified a: " + str(a))
@

The example below shows the sublist notation in the 2-d case. Higher dimensional cases are similar.

<<ndarray7, engine="python">>=
import numpy as np
a = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
print("a:\n" + str(a))
print("a[:,1]:\n" + str(a[:,1]))  # second column
print("a[0:2,1]:\n" + str(a[0:2,1]))  # first two rows, 2nd column
print("a[0:2,0:2]:\n" + str(a[0:2,0:2]))  # first 2 rows and columns
@

The example below shows the logical condition in 2-d. Higher dimensional cases are similar.

<<ndarray8, engine="python">>=
import numpy as np
a = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
print("a:\n" + str(a))
print("a < 3:\n" + str(a < 3))  
print("a[a < 3]\n" + str(a[a < 3]))  
a[a < 3] = 0  
print("modified a:\n" + str(a))
@

Referring to a multidimensional ndarray with a single index yields an ndarray obtained by fixing the first dimension to be the provided index and varying all other indices. For example, if \texttt{a} is a matrix then \texttt{a[1]} corresponds to the second row of that matrix. 

Another way to refer a subset of a two dimensional ndarray is using a list of two lists of coordinates. 

<<ndarray85, engine="python">>=
import numpy as np
a = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
print("a:\n" + str(a))
# first row
print("a[0]: \n" + str(a[0]))  
# first and third rows
print("a[[0, 2]]: \n" + str(a[[0, 2]])) 
# third and first rows
print("a[[2, 0]]: \n" + str(a[[2, 0]]))  
# refer to the (0,2) and (1,0) elements
print("a[[0,1],[2,0]]: \n" + str(a[[0,1],[2,0]]))
@


Assigning a new variable to an existing ndarray (or a part of it) does not create a new copy of the ndarray, but rather creates a new reference to the original ndarray.

<<ndarray9, engine="python">>=
import numpy as np
a = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8]) 
b = a[0:4]  # b refers to elements 0-3
b[1] = -99  # modify second element of b
print(a)  # a is modified as well
@


\subsection{Linear Algebra and Random Number Generation}

Numpy implements many arithmetic operators and linear algebraic concepts for ndarrays. The table below lists some of the more popular ones.

\begin{tabular}{|l|l|}
\hline
& \textbf{Binary Operators} \\ \hline
Operator & Description\\ \hline
\texttt{**}  & raise to a power (element-wise)\\ \hline
\texttt{maximum} & maximum of ndarrays (element-wise)\\ \hline
\texttt{minimum} & minimum of ndarrays (element-wise) \\ \hline
\texttt{dot} & matrix multiplication\\ \hline \hline
& \textbf{Unary Operators} \\ \hline
Operator & Description\\ \hline
\texttt{fabs} & absolute value\\ \hline
\texttt{sqrt} & square root \\ \hline
\texttt{exp} & exponentiation \\ \hline
\texttt{log} & logarithm \\ \hline
\texttt{sign} & sign (-1 for negative, 0  for zero, +1 for positive) \\ \hline
\texttt{cos} & cosine \\ \hline
\texttt{sin} & sine \\ \hline
\texttt{sum} & sum \\ \hline
\texttt{mean} & average \\ \hline
\texttt{var, std} & variance, standard deviation \\ \hline
\texttt{max, min} & max, min \\ \hline
\texttt{argmax, argmin} & index of max, index of min \\ \hline
\texttt{cumsum} & cumulative sum \\ \hline
\texttt{cumprod} & cumulative product \\ \hline
\texttt{diag} & matrix diagonal\\ \hline
\texttt{trace} & matrix trace\\ \hline
\texttt{det} & matrix determinant\\ \hline
\texttt{T} & matrix transpose \\ \hline
\texttt{inv} & matrix inverse \\ \hline
\texttt{pinv} & matrix pseudo inverse \\ \hline
\texttt{eig} & eigenvalues and eigenvectors\\ \hline
\texttt{svd} & singular value decomposition\\ \hline
\end{tabular}

\vspace{0.2in}

Some of these definitions apply specifically for the two dimensional case (for example determinant) while others extend to higher dimensions (absolute value). Many of the operators above can operate on specific dimensions, which are passed as optional argument to the \texttt{axis} parameter.

The example below demonstrates operating the mean function on entire ndarrays, on columns, and on rows.

<<ndarray851, engine="python">>=
import numpy as np
a = np.array([[0, 1], [2, 3]])
# global average
print("np.mean(a): \n" + str(np.mean(a)))
# average of columns
print("np.mean(a, axis = 0): \n" + str(np.mean(a, axis = 0)))
# average of rows
print("np.mean(a, axis = 1): \n" + str(np.mean(a, axis = 1)))  
@

The example below demonstrates linear algebraic operators such as matrix inverse and matrix multiplication. 

<<ndarray110, engine="python">>=
import numpy as np
a = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]]) + np.identity(3)
print("a: \n" + str(a))
a_inv = np.linalg.inv(a)
print("inverse of a: \n" + str(a_inv))
print("a times its inverse: \n" + str(np.dot(a,a_inv)))
@

Numpy also has a matrix object, which is a special case of a two dimensional ndarray. Matrix objects are different from ndarrays in that single dimensions (vectors) are treated as row or column matrices and can be inserted into a matrix computation with other two dimensional matrices. In addition, the multiplication operator \texttt{*} acts as matrix multiplication. 

<<ndarray9p5, engine="python">>=
import numpy as np
a = np.mat([[0, 1], [2, 3]])
print("a: \n:" + str(a))
print("a[:,0]: \n" + str(a[:,0]))  # column vector
print("a[0,:]: \n" + str(a[0,:]))  # row vector
# compute bilinear form v^T * A * v (matrix multiplication)
print("a[0,:] * a * a[:, 0]: \n" + str(a[0,:] * a * a[:, 0]))  
@

Note that if \texttt{a} was an ndarray then \texttt{a[:,0]} and \texttt{a[0,:]} would be both one dimensional ndarray objects rather than matrices with a specific row or column orientation.

Numpy also has set logic functionality.

<<ndarray112, engine="python">>=
import numpy as np
a = np.array(['a', 'b', 'a', 'b'])
b = np.array(['c', 'd'])
print("a: " + str(a))
print("np.unique(a): \n" + str(np.unique(a)))
print("np.union1d(a,b): \n" + str(np.union1d(a,b)))
print("np.intersect1d(a,b): \n" + str(np.intersect1d(a,b)))
@

Numpy also has functions for generating ndarrays containing pseudo random numbers. These include \texttt{permute} for generating a random permutation, \texttt{rand} for generating uniformly distributed random variables, and \texttt{normal} for generating Gaussian random variables. 

<<ndarray111, engine="python">>=
import numpy as np
print("np.random.normal(size=(2, 2)):")
print(np.random.normal(size=(2, 2))) # N(0,1) Gaussian
print("np.random.uniform(size=(2, 2)):")
print(np.random.uniform(size=(2, 2))) # uniform over [0,1]
print("np.random.randint(10, size=(2, 2)):")
print(np.random.randint(10, size=(2, 2)))  # Uniform over {1..10} 
print("np.random.permutation(6):")
print(np.random.permutation(6))  # random permutation over 1..6  
@

\subsection{Sparse Matrices in Python}

Scipy contains additional functionality that is useful for signal processing, sparse linear algebra, optimization, integration, and interpolation. Scipy's namespace subsumes Numpy so there is no need to separately import Numpy when Scipy is imported. We focus in this section on Scipy's sparse matrices, which are an extremely useful tool in data analysis, for example when representing text or other categorical features over a large set of possible values. 

Sparse matrices are similar to generic matrices, with the exception that most of its values are zero. This makes it possible to easily store very large matrices that have a manageable number of non-zero entries (and perform computation on such matrices). 

Python has several sparse matrix classes, which we describe below. Sparse matrix formats are typically split to (a) those that permit efficient modification of the matrix, and (b) those that admit efficient matrix operations. Once the matrix is constructed in full and is not expected to change, it is typically converted to a format in the second category above.

\subsubsection{Dictionary Method}

The dictionary method (DOK) represents non-zero entries using a dictionary mapping row-column pairs (keys) to values. This format is convenient for incrementally building a matrix, but is inefficient for matrix operation. 

\subsubsection{List of Lists}

List of lists (LIL) format stores the non-zero entries in a list of lists, where the first element of the list contains a list of the non-zero entries in the first row, the second element of the list contains a list of the non-zero entries in the second row, and so on. Each entry in the these lists is a pair of column-index and value. This format is convenient for incrementally constructing a matrix, but is inefficient for matrix operation. 

\subsubsection{Compressed Row and Column Representations}

Compressed Row and Column Representations store the non-zero elements using three arrays. The first array, \texttt{A}, holds all nonzero entries of M in left-to-right top-to-bottom order. The second array, \texttt{B}, contains in its $i$ value \texttt{B[i]} the index in \texttt{A} of the first non-zero element of row $i$. The third array, \texttt{C}, contains the column indices of the elements in \texttt{A}.

The compressed sparse row representation (CSR) maintains the non-zero matrix elements by storing the three arrays in the following order \texttt{A}, \texttt{C}, \texttt{B} (column arrays is stored before the row indices).
The compressed sparse column representation (CSC) is similar to the CSR representation, but with \texttt{C} keeping the row indices rather than column indices, and \texttt{B} keeping the indices in \texttt{A} where the non-zero values of each row start.

Compressed row and column representations facilitate efficient matrix computation, and typically dictionary or LIL representations are converted to compressed representation after the matrix is created and before the matrix computation begins. 

Both CSR and CSC enable fast matrix addition and multiplication by a scalar. CSC provide efficient column slicing but slow row slicing. CSR provide efficient row slicing but slow column slicing. Both representations provide fast element-wise product and matrix multiplication. Both representations are slow to add additional non-zero elements or replace existing non-zero element with zero. 

<<ndarray113, engine="python">>=
from scipy import sparse
from numpy import *
# create a sparse matrix using LIL format
a = sparse.lil_matrix((5,5))
a[0,0] = 1
a[0,1] = 2
a[1,1] = 3
a[2,2] = 4
print("a: " + str(a))
# convert a to CSR format
b = sparse.csr_matrix(a)
print("b + b: " + str(b + b))  # matrix addition
@

%-------------------------------------------------------
\subsection{Dataframes} 

Pandas is a package that provides an implementation of a dataframe object that can be used to store datasets. As in R, a dataframe is essentially a two dimensional array whose rows represent data instances and whose columns represent data attributes or features. In contrast to standard two dimensional arrays such as ndarray or matrices, dataframes can have different data types in different columns. For example, the first column may hold strings, the second may hold integers, and the third may hold a string. This example corresponds to a phone book of names (strings), phone numbers (integers), and addresses (strings). As in R, columns may be given names and these names may be used to access the columns making it unnecessary to separately keep meta-data describing the meaning of the different columns.

In the examples below we show how to create a dataframe and access it. The simplest way to create a dataframe is to call the \texttt{DataFrame} function with a dictionary whose keys are column names and whose values are lists of equal length.

<<pandas00, engine="python">>=
import pandas as pd
data = {"names" : ["John", "Jane", "George"], 
        "age" : [25, 35, 52],
        "height" : [68.1, 62.5, 60.5]
       }
DF = pd.DataFrame(data)
print("dataframe content: \n" + str(DF))
print("dataframe types: \n" + str(DF.dtypes))
@

Note that the columns are named appropriately, each column holds objects of a different type, and the rows are numbered starting from zero. Columns can be accessed using brackets and column names or the period operator, and rows can be accessed using the member function \texttt{ix}.

<<pandas20, engine="python">>=
import pandas as pd
data = {"name" : ["John", "Jane", "George"], 
        "age" : [25, 35, 52],
        "height" : [68.1, 62.5, 60.5]
        }
DF = pd.DataFrame(data)
DF["age"] = 35  # assign 35 to all age values
print("age column: \n" + str(DF["age"]))
print("height column: \n" + str(DF.height))
print("second row: \n" + str(DF.ix[1]))
@

As shown above, the dataframe values may be modified by referring to a column (or a row) on the left-hand side of an assignment operator. If the right-hand side has a list of the appropriate length, the values in that list will overwrite the current values in the dataframe. In a similar way, new column may be added.

<<pandas21, engine="python">>=
import pandas as pd
data = {"name" : ["John", "Jane", "George"], 
        "age" : [25, 35, 52],
        "height" : [68.1, 62.5, 60.5]
        }
DF = pd.DataFrame(data)
DF["weight"] = [170.2, 160.7, 185.5]
print(DF)
@

The dataframe object has many useful member function, many of which apply by default across along the dataframe columns, for example \texttt{sum}, \texttt{median}, and \texttt{abs}. Type \texttt{dir(DF)} where \texttt{DF} is a dataframe object to see a list of these functions. An optional \texttt{axis = 1} argument can modify these functions to apply on rows instead. 

<<pandas22, engine="python">>=
import pandas as pd
data = {"age" : [25.2, 35.4, 52.1],
        "height" : [68.1, 62.5, 60.5],
        "weight" : [170.2, 160.7, 185.5]
       }
DF = pd.DataFrame(data)
print("medians of columns: \n" + str(DF.median()))
print("medians of rows: \n" + str(DF.median(axis=1)))
@

The member function \texttt{apply} applies a function passed as an argument to the dataframe rows (or columns if the \texttt{axis=1} argument is passed).

<<pandas23, engine="python">>=
import pandas as pd
data = {"age" : [25.2, 35.4, 52.1],
        "height" : [68.1, 62.5, 60.5],
        "weight" : [170.2, 160.7, 185.5]
        }
DF = pd.DataFrame(data)
print(DF.apply(lambda z: z + 1))  # apply f(x)=x+1 to all columns
@

The example below shows how numpy and pandas work with missing values. Below, we insert missing values denoted by \texttt{nan} in the numpy package. When the pandas dataframe is created the missing values are converted to NaN. Functions typically ignore such missing values, but this default behavior may be modified as shown below. The dataframe member function \texttt{describe} computes basic summaries for each column (mean, median, minimum value, maximum value, etc.).

<<pandas24, engine="python">>=
import numpy as np
import pandas as pd
data = {"age" : [25.2, np.nan, np.nan],
        "height" : [68.1, 62.5, 60.5],
        "weight" : [170.2, np.nan, 185.5]
        }
DF = pd.DataFrame(data)
print("column means (NA skipped): \n" + str(DF.mean()))
print("column means: (NA not skipped)\n" + str(DF.mean(skipna = False)))
@

Pandas offers much more functionality for manipulating dataframes, handling missing values, and transforming dataframe values. We cover some of that functionality in Chapter \ref{chap:preprocessing}.

%-------------------------------------------------------
\section{Reading and Writing to Files}

\subsection{Reading and Writing Data in Text Format}

To read from a file or write to a file in Python, the file must first be opened in the appropriate mode using the \texttt{open} function (\texttt{r} for reading and \texttt{w} for writing). The object returned from the open function can then be used to read from the file or write to it in a variety of ways. The \texttt{close} function should be called at the end of the reading or writing process. 

A simple way to read a text file is to read it line by line using a \texttt{for} loop. The code below illustrates this by creating a list of words in a text file. The iterator returned from the file opening function iterates of text lines, and the function fucnction \texttt{split} converts a string representing a line into a list of strings separated by whitespaces representing words. 

<<engine="python",eval=FALSE>>=
# open file for reading
f = open("mobydick.txt", "r")
wordsList = list()
for line in f:  # iterate over all lines in file
  wordsInLine = line.split()  # create a list of words in line
  wordsList = wordsList + wordsInLine
f.close()
@

Continuing the example above, we convert the list into a set, an operation that removes duplicates. Doing so produces a list of distinct words known as the text document vocabulary. The second line below creates a restricted vocabulary containing words of length 10 or more.

<<engine="python",eval=FALSE>>=
V = set(wordsList)  # list of distinct words
Vp=[w for w in V if len(w) > 10]  # list of long words in V
@

Above, the structure \texttt{[w for w in V if len(w) > 10]} returns a list of all elements in \texttt{V} satisfying the specified condition (in this case distinct words in Moby Dick having 10 or more characters). This structure,  called list comprehension, is very powerful and can be used to create complex operations in a single line. It can be modified to \texttt{[f(w) for w in V if len(w) > 10]} for obtaining a list of the outputs \texttt{f(w)} of words in \texttt{V} with the required condition. 

The functions \texttt{write} or \texttt{writelines} can be used to write contents to a file. The code below demonstrates the use of \texttt{write}. Note that the file is opened in a writing mode (indicated by the second argument \texttt{w} to the \texttt{open} function).

<<os2, engine="python",eval=FALSE>>=
f = open("/home/joe/f2.txt", "w")
f.write("first line\n")
f.write("second line\n")
f.close()
@

\subsection{Reading and Writing Ndarrays in Binary Format}

Numpy offers several functions for reading and writing ndarrays. Specifically, the functions \texttt{numpy.load} and \texttt{numpy.save} read and write ndarrays in uncompressed binary format. There is no need to separately open and close the files. The standard file name extension for such files is \texttt{.npy}. 

<<os3, engine="python",eval=TRUE>>=
import numpy as np
import subprocess as sp
a = np.array([[1, 2, 3], [4, 5, 6]])
np.save('arr.npy', a)  # save ndarray to file
sp.call(["ls", "-l", "arr.npy"])  # call OS command ls
b = np.load('arr.npy')
print(b)
@

The function \texttt{numpy.savez} is similar but it saves the data in a compressed format and can take multiple arguments corresponding to several arrays. The standard file name extension for compressed binary format is \texttt{npz}. The function \texttt{numpy.load} detects the compressed format automatically and loads the data into a dictionary-like object that holds the multiple arrays.

<<os4, engine="python",eval=TRUE>>=
import numpy as np
a = np.array([[1, 2, 3], [4, 5, 6]])
b = a * 2
np.savez('filename.npz', arr1 = a, arr2 = b)
D = np.load('filename.npz')
print(D['arr2'])
@

\subsection{Reading and Writing Ndarrays in Text Format}

The function \texttt{numpy.loadtxt(filename)} reads a text file and converts it to an ndarray (an optional second argument specifies the delimiter). Different rows in the text file are copied into different rows in the ndarray. The function \text{numpy.savetxt(filename, arrayname)} saves an ndarray object to a text file. Despite their larger size on disk, text files are sometimes preferred due to the ease of reading them, for example using the Linux or Mac terminal.

<<os5, engine="python",eval=TRUE>>=
import numpy as np
import subprocess as sp
sp.call(["cat", "array.txt"])  # call OS cat command
a = np.loadtxt('array.txt', delimiter = ' ')
print(a)
np.savetxt('array2.txt', a)
@

The function \texttt{numpy.genfromtxt} is similar to \texttt{numpy.loadtxt} but it can handle structured arrays and missing values. 


\subsection{Reading and Writing Dataframes}

The Pandas functions \texttt{to\_csv} saves a dataframe to a text file using CSV (comman separated values) format. The function \texttt{read\_csv} reads a dataframe from a text file. 

The code below demonstrates a simple case where we save a dataframe and then load it back. Note that the first row of the saved text file contains the names of the columns with the first element of the first row being omitted. The first column of the second to last rows keeps contains the row index.

<<os6, engine="python",eval=TRUE>>=
import pandas as pd 
import subprocess as sp
df1 = pd.DataFrame({"age" : [25.2, 35.4, 52.1],
                    "height" : [68.1, 62.5, 60.5],
                    "weight" : [170.2, 160.7, 185.5]
                    })
df1.to_csv("df1.txt", sep = ",")  # save to file
sp.call(["cat", "df1.txt"])  # calls OS cat command
@

The code below reads the saved file back to a dataframe.

<<os7, engine="python",eval=FALSE>>=
df2 = pd.read_csv("df1.txt", sep = ",")
@

If the text file does not have an appropriate header row describing the column names as its first row, we can still use \texttt{read\_csv} with the argument \texttt{header = False}. Similarly, if the text file does not have a row index at the beginning of each row we can use \texttt{read\_csv} with the argument \texttt{index = False}. 

In some cases we need to read data from a text file whose format deviates from the above format. One way to deal with this is to first write a program to convert the text file into the appropriate format, and then call \texttt{read\_table}.

%-------------------------------------------------------
\section{Notes}

Python was introduced by Guido van Rossum in 1991 and has quickly gained popularity in a variety of fields, including system administration, data analysis, and web programming. The stable version Python 2.7 coexists with the new non-backward compatible Python 3.X (latest version is currently 3.5). Despite several improvements in Python 3.X, the community has been slow to adopt 3.X and many Python developers still use Python 2.7. 

An important part of the Python ecosystem is its package system. Numpy, Scipy, and Pandas are perhaps the most popular packages for data analysis, but many other useful high quality packages exist.

There are many good Python textbooks. One example is \cite{Lutz2011} that can be augmented with \cite{Lutz2013} for beginners. Such general introductory books are usually broad, but do not cover in detail data analysis packages. A couple of Python textbooks specifically aimed at data analysis are \cite{McKinney2013} and \cite{Bird2009}. These latter two books include description of packages that are useful for data analysis. Additional information regarding Python packages is usually best found in the web. 