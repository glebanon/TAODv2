%-----------------------------------
\section{Version Control}

Virtually all organized software development processes use version control. Version control can keep track of different versions of the software and enables reverting to a version that is different from the current one. This is very useful as often a problem is discovered in the software that necessitates an immediate roll back to a previous version without the problem (while the problem is studied and fixed). 

Version control is useful for a single developer who needs assitance managing the different versions of the code. Version control is extremely useful when several developers collaborate on a code base simulatenously. The developers can branch off the current version and work on their own projects, and later merge back their changes so that they are available to the other developers. The version control system takes care of merging multiple versions of the code assuming that there are no conflicts (if there are the developers are prompted to resolve the conflicts before the merge takes place).

There are two types of version control systems: centralized and distributed. Centralized version control systems such as CVS, Subversion, and Perforce, have a single server that contains all the versioned files, and several clients that check out files from the centaralized repository. In order to access the version control system on the centralized repository, such systems need to communicate over the netwwork. 

In distributed version control systems (such as Git or Mercurial), clients do not simply check out the latest snapshot of the files. Instead, the clients mirror the repository completely. There are several advantaged over centralized version control system: (a) each client stores a complete clone of the repository, which is useful for backup purposes, (b) much of the version control functionality can be done without network, and (c) many operations are much faster since they can be carried out locally. Nevertheless, in distributed version control system there is often a unique server that is designated as the primary server and that can be trusted to have the latest version. 

We start below with a description of the Git version control system. Git is one of the most popular version control system and has some advantages over older systems. It is also open source, which makes it attractive for low cost companies or academic researchers. We then describe Github, a hosted version of Git that has some additional functionality. We conclude with an older version control system called Subversion that is still widely used.

\subsection{Git}

Git was created by Linus Torvalds (the inventor of Linux) in 2005 and has since then increased in popularity to the point where it is today perhaps the most popular version control system. Google, Microsoft, Twitter, LinkedIn and many other companies use Git. 

We start below by covering local Git functionality (the repository exists on a single machine). Afterwards, we cover the more interesting functionality where there are mutliple Git repositories on different clients.

\subsubsection{Local Git}

A Git respository is a collection of files in a directory that contains a \texttt{.git} subdirectory. The files represent the current working version and the \texttt{.git} subdirectory contains additional information regarding other versions of the repository. 

Typically, a Git repository is created by cloning an existing respository from a different client. But to start an empty repository from scratch type \texttt{git init respositoryName} (first \texttt{cd} to the appropriate directory in the file system where you want the repository to be). A new directory is created with the respository name that has a \texttt{.git} subdirectory to store the version control information. 

To add files to the repository create a file and then type \texttt{git add fileName}. At that point the file is added to a logical version of the repository called ``the staging area''. The added files that are currently in the staging area are not yet added to the repository. To update the respository with the new files type the following command

<<eval=FALSE>>=
git commit --message "short message describing change"
@

If the message flag is missing Git will open up an editor and prompt you to enter a message in it. Git will commit upon exiting the editor. 

Files in the Git directory that are part of the index or repository are called ``tracked files''. Other files are ``untracked files'' and unless explicitly added to the respository using \texttt{git add} will not be added to it. The command \texttt{git status} shows the list of tracked and untracked files and the current status of the staging area.

The command \texttt{git commit} can also update the repository index with new versions of existing files. Specifically, after editing the respository files we can update the respository index (in the \texttt{.git} subdirectory) by typing the following command.

<<eval=FALSE>>=
git commit --message "short message describing change" fileNames
@ 

Alternatively, we can type the following command to commit all changes in the tracked files of the respository (in both cases the message flag can be suppressed in order to enter the description in an editor window).

<<eval=FALSE>>=
git commit -a --message "short message describing change" fileNames
@ 


So far we have considered a linear development process where each commit updates the previous commit. Using the analogy of a directed graph where nodes are commits and outgoing edges from a commit node represent previous commits, this corresponds to a linear graph or chain leading from the most recent commit to the previous commit until we get to the first commit (Figure~\ref{fig:git:linear} visualizes this development pattern).

\begin{center}
\begin{figure}
\includegraphics[scale=0.17]{pdf/git_linear.pdf}
\caption{Linear development pattern in a version control system. Each node corresponds to a commit and outgoing edges point from a commit to its preceding commit.}
\label{fig:git:linear}
\end{figure}
\end{center}

In some cases it is desirable to branch out from the main line of development and create a new line of commits, for example when developing a new feature in a system. The main line can represent the stable system and subsequent commits in that line can capture minor bug fixes, while the branch line can have a line of commits representing work on the new feature. When the new feature is complete the branch can be merged with the main line (more branch merges that soon). Figure~\ref{fig:git:branch} illustrates a development pattern involving two branches.

To create a branch (without moving to it) type \texttt{git branch branchName} (the command \texttt{git branch} lists all branches). To move from the current branch to the new branch type \texttt{git checkout branchName}. Any subsequent commits will update the specified branch. 


\begin{center}
\begin{figure}
\includegraphics[scale=0.17]{pdf/git_branch.pdf}
\caption{Branch development pattern in a version control system. The bottom row represents the master (main) branch cosisting for example of minor bug fixes. After the second commit, development of the new feature commenced with two subsequent commits. Then, a minor bug was discovered and a fix was deployed to the master branch rather than the feature branch since the feature work was not completed. That commit was followed by another minor bug fix resulting in the sixth commit in the master branch. At that point we have two branches that hold different versions of the system.}
\label{fig:git:branch}
\end{figure}
\end{center}



Referring to specific commits in Git is usually done via refs, which are references to commits. The ref \texttt{HEAD} refers to the the commit that you most recently checked out. It updates automatically to the most recent commit as the developer checks in or checks out new versions. 

By default the initial branch is called \texttt{master}. The keyword \texttt{master} or other branch names are refs that self update to refer to the commits at the top of the corresponding branches. If you most recently checked out \texttt{master} then \texttt{HEAD} and \texttt{master} refer to the same commit. Appending a branch name (including \texttt{master}) with $\sim$\texttt{k} creates a ref to the commit that is \texttt{k} commits before the commit at the top of the branch (appending \^{} corresponds to $\sim$1 and \^{}\^{} corresponds to $\sim$2). We can also refer to commits using refs that are generated automatically by a secure hash algorithm (SHA-1). To see the SHA-1  codename that correspond to one of the refs above type  \texttt{git rev-parse refname} where \texttt{refname} represents the ref. 

<<engine="bash">>=
git rev-parse master~2
@

Branch names are easier to remember and frequently more useful than refs generated by the SHA-1 algorithm.

The command \texttt{git log} prints the respository history: the commits annotated with dates, author, files that were changed, and the messages that were used to document the commits. Note below the SHA-1 codes displaying the most recent commits and the commit messages.

<<engine="bash">>=
git log | head
@

The command \texttt{git diff} displays the difference between the current working version and the index staging area. The command \texttt{git diff} can also show differences between two other versions, but that requires passing references to the versions as arguments. For example, \texttt{git diff master}$\sim$1 \texttt{ master} prints diff between the commit on top of \texttt{master} and the one before it. 

<<engine="bash">>=
git diff master~1 master | head 
@

The diff command prints the difference in the two commits in a specific format that takes some getting used to. In general lines that start with - represent deleted lines and lines that start with + represent new lines. 

\subsubsection{Remote Git}

\subsubsection{Additional Features}

There are various visualization tools for Git that draw the repository history as a directed graph with each commit being a node having an outgoing edge to the previous commits. Examples of such tools are \texttt{gtk+} (Linux Gnome) and \texttt{gitx} (Mac OS). 

The editor that Git starts automatically for prompting documentation of commits (without \texttt{--message} flags) can be set using the \texttt{GIT\_EDITOR} shell environment variable. For example, we can set it in ZShell to Emacs using \texttt{export GIT\_EDITOR="emacs"}.


\subsection{Github}



\subsection{Subversion} 

%-----------------------------------
\section{Build Tools}
\subsection{Make}
\subsection{Ant}
\subsection{Gradle}


%-----------------------------------
\section{Exceptions}

Code can fail due to a variety of reasons. Examples include inadmissable input, incorrect logic, and undefined values such as division by zero. It is important to not let the code fail inappropriately and rather handle it in a carefully designed manner. 

Traditionally, handling potential failures was done by checking input carefully before entering a function and making sure the output value is properly assigned. In the calling enviornment, the value returned from the function is checked again and handled appropriately if the returned value indicates a failure.

Below is an example in C++ where a function attempts to insert an object into a list in a specific position. The code first check if the list is long enough and if not returns with a specific code (-1). Otherwise, the function calls \texttt{insert\_res} and returns the return value from that function.

<<engine="python",eval=FALSE>>=
int insertInPosition(List L, int pos, Object o) {
  if (pos >= L.size()) 
    return(-1);  // return -1 value for a fail
  int insert_res = L.insert(pos, o);
  return(insert_res);
}
@

The process described above requires (a) writing code that will diagnose whether there is a problem and (b) handle the problem, and so at multiple key places such as function entry points and function return. Doing so eventually leads to writing duplicated code that is hard to maintain. 

Exception handling is a more effective way of handling code failures that at this point is supported in many major programming languages, including C++, Java, Python, and R. We describe below exception handling in Python. Exception handling in other languages is similar and once the concept is clear it is easy to learn how to use it in any of the languages above.

Exceptions are objects that represent an problematic situation that needs to be logged or handled. Usually, exception classes may be implemented in the language definition or standard library, or may be defined and implemented by the programmer. In either case, exception classes inherit from the base exception class (for example, in Python it is \texttt{BaseException}) or one of its descendents. 

When the appropriate situation is discovered, the exception is activated. This is called throwing an exception. At that point program execution is suspended and is transferred to the try block containing the code that lead to the thrown exception. 

We describe the process below in the case of the Python programming languages. The process is similar (though some differences remain) in other programming languages. 

The code below computes a mathematical expression, and it requires that the argument be a positive integer. We thus check the argument and throw an exception if needed. 

<<engine="python",eval=FALSE>>=
import math

def foo(x):
  if not isinstance(x, int):
    raise TypeError("arguments to foo should be integers")
  if x <= 0:
    raise ValueError("arguments to foo should be positive")
  return(x + math.log(x))

foo(-3)  # exception triggered and program halted 
foo(3)  # never executed
@

In the example above, we did not have specific code to handle the thrown exception, and thus the program is halted immediately and never reaches the last line. Also, if we have a function that calls another function that raises an exception without exception handling code the program halts and no code afterwards is executed. 

When the program is halted we get a printout of the traceback object that records the program path that lead to the exception (for example which function called the function that triggered the exception). This information is very useful in debugging and in understanding the behavior of complex code. For example, the traceback below shows the path \texttt{bar(3)} followed by \texttt{foo(-x)}.

<<engine="python",eval=FALSE>>=
def bar(x): 
  foo(-x)
  
bar(3)  

## ----------------------------------------------
## ValueError   Traceback (most recent call last)
## <ipython-input-17-2f0fa4d9f487> in <module>()
## ----> 1 bar(3)
##
## <ipython-input-15-a80ffbcd5b6f> in bar(x)
##      1 def bar(x):
## ----> 2  foo(-x)
##      3 

## <ipython-input-12-1165b706a01c> in foo(x)
##      3  raise TypeError("arguments to foo should be integers")
##      4    if x <= 0:
## ----> 5 raise ValueError("arguments to foo should be positive")
##      6    return(x + math.log(x))
##      7 
##
## ValueError: arguments to foo should be positive
@

\subsection{Handling Exceptions}

In order to trigger a more specific handling of the exception (rather than simply terminate the program), we include code that may trigger exceptions in a \texttt{try}-\texttt{except} clause. The code follows the \texttt{try} keyword is executed, and if an exception is triggered execution passes immediately to the code following the \texttt{except} keyword that handles the exception. After exception handling code is finished, the program continues to execute the code following the \texttt{except} block (rather than terminate).

<<engine="python",eval=TRUE>>=
import math

def foo(x):
  if not isinstance(x, int):
    raise TypeError("arguments to foo should be integers")
  if x <= 0:
    raise ValueError("arguments to foo should be positive")
  return(x + math.log(x))

try: 
  foo(-3)  # exception triggered and program halted 
  foo(3)  # never executed
except: 
  print("exception in sequence of foo() calls")
print("program resumes execution and is not terminated")
@

The syntax above catches and handles all exceptions in the same way. We can write custom handling code for different exceptions by including multiple 
\texttt{except} blocks followed by the exception class that they handle. If there are multiple \texttt{except} blocks and an exception occurs, the program executes the exception handling code and then continues after the last \texttt{except} block. An optional block \texttt{else:} is called if no exception has been handled (\texttt{else:}) and an optinoal block \texttt{finally:} is always called and can be used to host cleanup code (e.g., closing a file or database connection).

<<engine="python",eval=TRUE>>=
import math

def foo(x):
  if not isinstance(x, int):
    raise TypeError("arguments to foo should be integers")
  if x <= 0:
    raise ValueError("arguments to foo should be positive")
  return(x + math.log(x))

try: 
  foo(-3)  # exception triggered and program halted 
  foo(3)  # never executed
except TypeError:  # handle TypeError exceptions
  print("Incorrect Type in sequence of foo() calls")
except ValueError:  # handle ValueError exceptions
  print("Non-positive value in sequence of foo() calls")
else: 
  print("no exceptions handled")  
finally:
  print("always handled")  
print("program resumes execution and is not terminated")
@

If we want to write \texttt{except} blocks that handles exceptions, but also terminate the program with printing the traceback object to the console (as if the exception has never been caught) we can include the \texttt{raise} keyword (with no arguments) at the end of the appropriate \texttt{except} block. In this case, the code in the \texttt{except} block up to the \texttt{raise} keyword is executed followed by program termination and printing of the traceback object.

If there are multiple \texttt{except} blocks and an exception is raised, only the first match will execute. An exception can match an \texttt{except} block also if it specifies an exception class that it inherits from. This is useful for handling some exceptions in a particular way, and all other exception in a default way: include the specific exceptions in separate \texttt{except} blocks first followed by an \texttt{except Exception:} block that will handle all remaining exceptions (since all exception classes inherit from the base Exception class). Since the first matching \texttt{except} block is used, multiple \texttt{except} blocks are ordered from more specific exceptions to less specific exceptions.

If we want access to the exception object in the \texttt{except} block, we can modify the syntax \texttt{except TypeError:} to \texttt{except TypeError as e:} that exposes the exception object as \texttt{e} in the block.

<<engine="python",eval=TRUE>>=
import math

def foo(x):
  if not isinstance(x, int):
    raise TypeError("arguments to foo should be integers")
  if x <= 0:
    raise ValueError("arguments to foo should be positive: " + str(x))
  return(x + math.log(x))

try: 
  foo(-3)  # exception triggered and program halted 
  foo(3)  # never executed
except TypeError:  # handle TypeError exceptions
  print("Incorrect Type in sequence of foo() calls")  
except ValueError as e:  # handle ValueError exceptions
  print("Non-positive value in sequence of foo() calls:")
  print(e.args)
print("program resumes execution and is not terminated")
@



\subsection{Custom Exceptions}

In some cases it is useful to define new exception classes that represent specific situations. To  do so we simply specify that it inherits from the base \texttt{Exception} class. The class name usually communicate what went wrong. 


<<engine="python",eval=FALSE>>=
import math

# Custom exception: either type or value error
class InvalidTypeOrValueError(Exception):
  def __init__(self, a_val, a_type):  # custom constructor
    # calls super class constructor (Python 3 syntax)
    super().__init__("incorrect type and value. " + 
      "val: " + str(a_val) + " " + "type: " + str(a_type))
    self.val = a_val
    self.type = a_type
    
def foo(x):
  if not isinstance(x, int) or x<=0:
    raise InvalidTypeOrValueError(x,type(x))
  return(x + math.log(x))
  
try: 
  foo(-3) 
  foo(3)
except InvalidTypeOrValueError as e:
  print("Incorrect type or value in sequence of foo() calls: ")
  print(e.args)

## Incorrect type or value in sequence of foo() calls: 
## ("incorrect type and value. val: -3 type: <class 'int'>",)
@

%-------------------------------------------------------------------
\section{Documentation Tools}

It is useful to write self-documenting code in the sense that the source code files contain significant documentation about the code implementation as well as how to use it. Many programming languages have a built-in documentation format that if the programmer adheres to can generate separate documentation files based on the in-code comments. Below we describe first Docstrings - a built-in documentation format used in Python, and later describe Javadoc - a similar format that is used in Java.

\subsection{Docstrings} \label{sec:tools:docstrings}

Python docstrings appear as a string literal in the first statement following the definition of functions, methods, classes, and modules. Below is an example of a docstring documention of the Point class from Chapter~\ref{chap:Python}. 

<<engine="python",eval=FALSE>>=
class Point(object):
  "A point in a two dimensional space"

  def __init__(self, x=0, y=0):
    """Initializes the point object to the origin by default, or otherwise 
    the initializes to the passed x,y arguments."""
    self.x = x
    self.y = y
  def __del__(self):
    "Prints a message when an object is destroyed."
    print "destructing a point object"
  def displayPoint(self):
    "Prints the object by displaying its x and y coordinates."
    print "x: %f, y: %f" % (self.x, self.y)
    
help(Point)  # shows class doctring
help(Point.displayPoint)  # shows method docstring
@

Docstrings can be accessed by the \_\_doc\_\_ attribute on objects inside the program or by typing \texttt{help(X)} in the Python prompt where \texttt{X} is the name of a class, method, function, or module.
 
The docstring for a class should summarize its behavior and list the public methods. The docstring of a function or method should describe its effect, the arguments, the return values, and any restriction on its usage. The docstring for a module should list the classes and functions that are exported by the module with brief high-level descriptions.

Another way to generate documentation from docstrings is using the pydoc program that can be called from the OS prompt as follows: \texttt{pydoc X} where is a built-in or programmer defined module, function, or class (in the latter case of built-in a path should be provided in \texttt{X} including a slash character).

For example, typing at the OS prompt \texttt{pydoc ~/Point.py} produces the following documentation for the Point class above.

\begin{verbatim}
FILE
    /Users/glevanon/tmp.py

CLASSES
    __builtin__.object
        Point

    class Point(__builtin__.object)
     |  Represents a point in a two dimensional space
     |
     |  Methods defined here:
     |
     |  __del__(self)
     |      Prints a message when an object is destroyed
     |
     |  __init__(self, x=0, y=0)
     |      Initializes the point object to the origin by default, 
     |      or otherwise the initializes to the passed x,y arguments
     |
     |  displayPoint(self)
     |      Prints the object by displaying its x and y coordinates
     |  
     
-- truncated --

Adding to the pydoc command the \texttt{-w} flag outputs the generated documentation to a file in an HTML format.
\end{verbatim}

A more sophisticated and recent alternative to pydoc is the Sphinx program that can include math formulas, ipyhton interactive sessions, inheritance diagrams, and figures generated using matplotlib. Since it is considerably more complex than pydoc we do not discuss it in this book. More details about Sphinx are availble at \href{http://sphinx-doc.org}{http://sphinx-doc.org}.

\subsection{Javadoc}



%-----------------------------------
\section{Unit Testing}
\subsection{Unit Testing in Java with JUnit}
\subsection{Unit Testing in Python with Nose}

%-----------------------------------
\section{Program Diagnostics}
\subsection{Debugging}


Core R features some debugging and profiling functionality. Additional debugging and profiling functionality is available through third party packages, as described at the end of this section.

The \texttt{print} and \texttt{cat} functions display values of relevant variables at appropriate positions and can be used while debugging code. Specifically, the \texttt{print} function displays the value of a variable, while the \texttt{cat} function displays the concatenation of values of several variables passed as parameters.

The \texttt{browser} function suspends the execution of the R code, providing a interactive prompt through which the programmer can evaluate variables or execute new R code while debugging. Other options include stepping through line by line (by typing \texttt{n}), continuing execution (by typing \texttt{c}), or halting execution (by typing \texttt{Q}). The interactive session below demonstrates debugging with the \texttt{browser} function.

<<engine="Rcpp",eval=FALSE>>=
foo2=function(i) {
	a = i + 1;
	b = a + 1;
	browser();
	a = b + 1;
	return(b)
}
> foo2(3)
Called from: foo2(3)
Browse[1]> a  # display the value of a
[1] 4
Browse[1]> b  # display the value of b
[1] 5
Browse[1]> n  # executes next command
debug: a = b + 1
Browse[2]> c  # continue execution
[1] 5
@

The function \texttt{debug} binds the \texttt{browser} function to a user-specified function, invoking a debug session at each call site of said function.  The \texttt{undebug} cancels the binding.

<<engine="Rcpp",eval=FALSE>>=
foo3=function(i) {
	a = i + 1;
	b = a + 1;
	a = b + 1;
	return(b)
}
> debug(foo3)
> foo3(1)
debugging in: foo3(1)
debug: {
    a = i + 1
    b = a + 1
    a = b + 1
    return(b)
}
Browse[2]> n  # execute first command
debug: a = i + 1
Browse[2]> n  # execute next command
debug: b = a + 1
Browse[2]> a  # display value of a
[1] 2
Browse[2]> p=2*a+2  # define a new variable
Browse[2]> p
[1] 6
Browse[2]> n  # executes next command
debug: a = b + 1
Browse[2]> b
[1] 3
Browse[2]> c  # continue execution
exiting from: foo3(1)
[1] 3
> undebug(foo3)
@

The \texttt{trace} function accepts the name of a function as a parameter and prints the function call with the passed arguments each time the function executes. If an error occurs, the variable \texttt{.Traceback}, a character array containing the currently active function calls, appears in the workspace.

Additional debugging functionality is available from contributed packages. In particular,  the \texttt{debug} package \cite{Bravington2003} provides capabilities similar to those of standard graphical debuggers, including a graphical window showing the current command, setting conditional breakpoints, and the opportunity to continue debugging after an error. Another package is \texttt{edtdbg}, which integrates R debugging with external text editors such as vim.

Profiling code refers to diagnosing which parts of the code are responsible for heavy computational efforts and memory usage. The function \texttt{Rprof(X)} starts a profiling session and saves the information to the file \texttt{X}. A call \texttt{Rprof(NULL)} indicates the end of the profiling session and \texttt{summaryRprof} shows the profiling summary.

<<Rprofiler, eval=T>>=
# start profiling
Rprof("diagonsisFile.out")
A = runif(1000)  # generate a vector of random numbers in [0,1]
B = runif(1000)  # generate another random vector
C = eigen(outer(A,B))
Rprof(NULL)  # end profiling
summaryRprof("diagonsisFile.out")
@

Total time is time spent in the function and its respective call subgraph; self time is the time spent only in the function itself. In the example below, the function \texttt{eigen} is responsible for nearly 100\% of the total time, but most of the execution time occurs within other functions called from within \texttt{eigen} (see the second report above). The methods that are called from within \texttt{eigen} are clearly the computational bottleneck, as the outer product and the generation of random samples are not responsible for any substantial total time.

See \href{http://cran.r-project.org/doc/manuals/R-exts.pdf}{http://cran.r-project.org/doc/manuals/R-exts.pdf} for more information on \texttt{Rprof} and a discussion on profiling memory usage. The packages \texttt{proftools} and \texttt{profr} provide additional profiling functionality including analyzing the call graphs.


\subsection{Speed Profiling}
\subsection{Memory Profiling}

%-------------------------------------------------------------------
\section{Libraries}
\subsection{BLAS, LINPACK, and LAPACK}
\subsection{Eigen and Armadillo}
\subsection{GNU Scientific Library}
\subsection{Boost}