%-----------------------------------
\section{Version Control}

Version control systems manage different versions of the software and it enables switching back and forth between different versions. This is very useful since most development process are composed of many small incremental steps rather than one single monolithic and immediate contribution. For example, if a problem is discovered in one of the recent version the version control system can revert back to an earlier version without the problem right away. After the revert step the problem can be studied and fixed with less urgency. 

Coneptually, each version can be thought of as a node in a graph with outgoing edges to another node that represents the previous version. Version control system typically store only the differences between subsequent nodes in order to reduce storage space and avoid unnecessary redundency. Each version or node is annotated with the author, the date and time the version was committed to the system, and an explanation of the changes. 

Version control is useful also for a single developer, but it is extremely useful when several developers simulatenuosly collaborate on a code base. Developers working on different projects can work on a part of the system by branching off from the current version, creating a version dedicated to their project that does not impact other versions. When the project work is done the separate branch can be merged back into the main branch that represents the current version of the stable system. Merging one branch into another is done automatically by the version control system, unless there are conflicts that it cannot resolve (in which case the developer needs to resolve the merge conflicts manually).

There are two types of version control systems: centralized and distributed. Centralized version control systems such as CVS, Subversion, and Perforce, have a single server that contains all the repository information, and several clients that check out files from the centaralized repository. In order to access the version control system on the centralized repository, such systems need to communicate over the netwwork. 

In distributed version control systems (such as Git or Mercurial), clients do not simply check out the latest snapshot of the files. Instead, the clients mirror the entire version control repository including the complete version history. Distributed version control systems have  several advantaged over centralized version control system: (a) each client stores a complete clone of the repository, which is useful for backup purposes, (b) much of the version control functionality can be done without network connectivity, and (c) many operations are much faster since they can be carried out locally. 

In some cases, distributed version control system do have a single unique server that is designated as the primary server and that can be trusted to have the latest version. New clients typically copy the repository from that designated server, but as described above all clients hold a copy of the entire version history. 

We start below with a description of Git, a popular distributed version control system. It is also open source, which makes it attractive for low cost companies or academic researchers and forms the base for GitHub, a popular version control system hosted in the cloud that has some additional functionality. We conclude with a description of Subversion, an older centralized version control system that is still in wide use.

\subsection{Git}

Git was created by Linus Torvalds (the inventor of  Linux) in 2005 and has since then increased in
popularity to the point where it is today  perhaps the most popular version  control system. Many
major companies such  as Google, Microsoft, Twitter, and  LinkedIn use Git, as well  as many small
companies and start-ups

We start below by covering local Git functionality, where the repository exists on a single machine. Afterwards, we cover the case where multiple clients (or a client and a server) have copies of the same repository.

\subsubsection{Basic Functionality of Local Git}

A Git respository is a collection of files in a directory that contains a \texttt{.git} subdirectory. The files represent the current working version and the \texttt{.git} subdirectory contains additional information that allows tracking different versions and switching between them. 

After installing Git (if it is not already installed on your computer by default), the developer needs to enter his or her name and email address. These details will be recorded as part of the version log messages and are very useful when collaborating with other developers. The name and email address can be entered in the shell as follows.

<<eval=FALSE>>=
git config --global user.name "Guy Lebanon"
git config --global user.email "glebanon@gmail.com"
@

Git occasionally uses an editor to prompt the developer to enter a message describing the new version. To inform Git about your favorite editor set the \texttt{GIT\_EDITOR} shell environment variable. For example, in bash or zshell we can set the \texttt{GIT\_EDITOR} to the Emacs editor using the following shell command \texttt{export GIT\_EDITOR="emacs"}. It is useful to add such a line in your shell initialization file (\texttt{.zshrc} for zshell and \texttt{.bashrc} in bash).

Typically, a Git repository is created by cloning an existing respository from a different computer. But to start an empty repository from scratch use the following command sequence.

<<eval=FALSE>>=
# change to parent directory where repository should lie
cd dir_name
# create a new directory representing repository
git init respository_name  
# enter directory representng new repository
cd respository_name  
@

The new directory will have a \texttt{.git} subdirectory that stores the version control information. 

To add files to the repository, create a file in the respoistory directory and then type \texttt{git add file\_name}. At that point the file is added to a logical version of the repository called ``the staging area''. The added files that are currently in the staging area are not yet added to the repository. To update the respository with the new files we need to type \texttt{git commit}. Using the sequence \texttt{git add X} and \texttt{git commit} we can add multiple files and directories to the repository. See below for a short example. 

<<eval=FALSE>>=
cd dir_name  
git init respository_name  
cd respository_name  
touch new_file  # create an empty file
git add new_file  # add new file to staging area
git commit -m "demo commit: adding an empty file new_file"

## [master (root-commit) 42a72e0] demo
## 1 file changed, 0 insertions(+), 0 deletions(-)
## create mode 100644 a
@

The message flag \texttt{-m} followed by the comment describing the version may be ommited, in which case Git will open up an editor and prompt you to enter the commit message in it (see above on how to inform Git on which editor to use). Git will execute the commit with the edited message upon saving and exiting the editor. 

Files in the Git directory that are part of the index or repository are called ``tracked files''. Other files are considered ``untracked files'' and unless explicitly added to the respository using \texttt{git add} will not be added to it. The command \texttt{git status} shows the list of tracked and untracked files and the current status of the staging area.

<<eval=FALSE>>=
git status

## On branch master
## nothing to commit, working directory clean
@

The command \texttt{git commit} can also update the repository with new versions of existing files. Specifically, after editing the respository files we can update the respository (in the \texttt{.git} subdirectory) with the new version by \texttt{git commit file\_name}. See below for a short example.

<<eval=FALSE>>=
cd dir_name  
git init respository_name  
cd respository_name  
touch new_file  # create an empty file
git add new_file  # add new file to staging area
# commit addition
git commit -m "demo commit: adding an empty file new_file"  
echo 123456 >>! new_file  # add some text to empty file
# commit new version of new_file
git commit -m "added 123456 to file" new_file  

## [master 9110e49] added 123456 to file
## 1 file changed, 1 insertion(+)
@ 

The command \texttt{git commit -a} commit changes to all files that are tracked by the repository and have changed since the last commit.  

<<eval=FALSE>>=
git commit -a -m "updating multiple files"
@ 

\subsubsection{Branches and Merges}

We considered above a linear development process where each commit updates the previous commit. Using the analogy of a directed graph where nodes are commits and outgoing edges connect commits to previous commits we have a linear graph leading from the most recent commit back in time to previous commits until we get to the first commit. Figure~\ref{fig:git:linear} visualizes this development pattern.

\begin{center}
\begin{figure}
\includegraphics[scale=0.17]{pdf/git_linear.pdf}
\caption{Linear development pattern in a version control system. Each node corresponds to a commit and outgoing edges point from a commit to its preceding commit.}
\label{fig:git:linear}
\end{figure}
\end{center}

\begin{center}
\begin{figure}
\includegraphics[scale=0.17]{pdf/git_branch.pdf}
\caption{Branch development pattern in a version control system. The bottom row represents the master (main) branch cosisting for example of minor bug fixes. After the second commit, development of the new feature commenced with two subsequent commits. Then, a minor bug was discovered and a fix was deployed to the master branch rather than the feature branch since the feature work was not completed. That commit was followed by another minor bug fix resulting in the sixth commit in the master branch. At that point we have two branches that hold different versions of the system.}
\label{fig:git:branch}
\end{figure}
\end{center}


In some cases it is desirable to branch out from the main line of development (usually called the \texttt{master branch} and create a new line of commits in parallel, for example when developing a new feature in a system. For example, the master branch can reprsent the stable system and subsequent commits in master represent minor bug fixes. The secondary branch may represent work on a new feature that is added to the system and its line of commits represent work on that project. When the new feature is complete the branch can be merged back into the master branch. Figure~\ref{fig:git:branch} illustrates such a development pattern involving two branches.

The command \texttt{git branch branch\_name} creates a branch without switching to it. The command \texttt{git branch} lists all branches. To switch to a different branch type \texttt{git checkout branch\_name}. Any subsequent commits will update the new branch. The initial branch is called \texttt{master}. 

<<eval=FALSE>>=
git branch new_branch  # create a new branch
git branch  # list all branches

## * master
##   new_branch
git checkout new_branch  # move to new_branch
git branch  # list all branches

##   master
## * new_branch
@ 

Referring to specific commits in Git is usually done via refs, which are references to commits. The ref \texttt{HEAD} refers to the the most recent commit on the current branch (it updates automatically). Branch names are also refs that update automatically to refer to the most recent commit in the corresponding branch. If the current checked out branch is \texttt{master} then the two refs \texttt{HEAD} and \texttt{master} refer to the same commit. 

Appending a branch name (including \texttt{master}) with $\sim$\texttt{k} creates a ref to the commit that is \texttt{k} commits before the commit at the top of the branch. Appending to the branch name \^{} corresponds to $\sim$1 and \^{}\^{} corresponds to $\sim$2 (for example \texttt{master\^{}\^{} is equivalent to \texttt{master}$\sim$}\texttt{2}). 

Commits can also be identified by refs generated automatically using a secure hash algorithm (SHA-1)\footnote{SHA-1 algorithm is using hashing to assign codenames to commits rather than sequential numbers due to the distributed nature of Git (when you commit a change, Git doesn't know what other commits occurred on other clients. The codenames are displayed as 40 character hexadecimal strings.}. To see the SHA-1 codename that correspond to one of the refs above type  \texttt{git rev-parse ref\_name} where \texttt{ref\_name} represents the ref. The 40 character SHA-1 refs can also be replaced by shortened SHA-1 versions.

<<engine="bash">>=
git rev-parse master~2  # display SHA-1 codename
git rev-parse --short master~2  # display shortened SHA-1 codename
@

Branch names are easier to remember and thus usually more useful than refs generated by the SHA-1 algorithm.

To replace the current version with an alternative version we use \texttt{git checkout ref\_name}. This can replace the current version with an older or a newer version on the same branch or on a different branch depending on the specified ref. The example below adds text to a new file, adds some more text, and then reverts to the previous version. 

<<eval=FALSE>>=
git init demo_repos
cd demo_repos
echo 123 > demo_file
git add demo_file
git commit -a -m "adding demo_file containing 123"
echo 456 >>! demo_file
git commit -a -m "adding 456 to demo_file"
cat demo_file

## 123
## 456
git checkout master~1  # change version to previous version
cat demo_file

## 123
@

At some point we may want to merge one branch into another. For example, in the situation described in Figure~\ref{fig:git:branch} we may wish to merge the feature branch into the master branch after the the feature development work is finished. The command \texttt{git merge branch\_name} merges \texttt{branch\_name} into the current branch. 

<<eval=FALSE>>=
git init demo_repos
cd demo_repos
echo 123 > master_file
git add master_file
git commit -a -m "added master file with 123"

## [master (root-commit) cb133d5] added master file with 123
##  1 file changed, 1 insertion(+)
##  create mode 100644 master_file
git branch feature1
git checkout feature1

## Switched to branch 'feature1'
echo abc > feature_file
git add feature_file
git commit -a -m "added feature_file with abc"

## [feature1 5c82dfc] added feature_file with abc
## 1 file changed, 1 insertion(+)
#3 create mode 100644 feature_file
git checkout master

## Switched to branch 'master'
git merge feature1  # merge feature1 branch into master

## Updating cb133d5..5c82dfc
## Fast-forward
## feature_file | 1 +
## 1 file changed, 1 insertion(+)
## create mode 100644 feature_file

ls  # both files appear in master after the merge
## feature_file master_file
@

A merge creates a new commit that has two outgoing edges into the two merged commits (see Figure~\ref{fig:git:branch-merge}). After the merge, we can keep the merged branch alive and add more commits to it (possibly to be merged again later), or we may delete the branch that was merged and continue development from the current branch (for example \texttt{master}) and consider creating a new branch in the future if needed.

\begin{center}
\begin{figure}
\includegraphics[scale=0.17]{pdf/git_branch_merge.pdf}
\caption{A feature development branch merged into the master branch.}
\label{fig:git:branch-merge}
\end{figure}
\end{center}

Rebasing is a variation of merging that converts the parallel branches pattern in Figure~\ref{fig:git:branch} to a linear pattern with the branch that is rebased becoming a linear continuation of the current branch. To rebase a branch into the current branch use the command \texttt{git rebase branch\_name}. Figure~\ref{fig:git:branch-rebase} illustrates this process. Merge and rebase have different pros and cons and sometimes different organizations use one alternative over the other.

<<eval=FALSE>>=
git checkout feature1
git rebase master  # rebase master into feature1 branch
@


\begin{center}
\begin{figure}
\includegraphics[scale=0.17]{pdf/git_branch_rebase.pdf}
\caption{The master branch rebased into the feature development branch.}
\label{fig:git:branch-rebase}
\end{figure}
\end{center}


\subsubsection{Conflicts}

When a merge is executed changes in the merged branch are incorporated into the current branch. If there are no conflicts (as in the example above where the work in the feature branch affects files that are different from the files that are modified in the master branch) the merge proceeds automatically. But in some cases there are conflicts that Git cannot resolve, for example if both commits modify the same line in the same file in different ways. In this case, conflicted merge modifies the conflicted files by inserting markers where there are conflicts. 

Below is a portion of a file that underwent a merge with a conflict. Git edits the file and adds markers showing the conflict. It takes some experience to read the markers below, but basically content following \texttt{<<<<<<} marker corresponds to one version and content following \texttt{=======} corresponds to the other version. The marker \texttt{>>>>>>>} specifies the end of the conflict region. 

\begin{verbatim}
this part is in agreement between the two branches 
  - no conflict exists

<<<<<<< HEAD
This is an edit in the incoming branch that conflicts 
  with the existing branch

=======
...
This is the edit in the current branch that conflicts 
   with the incoming branch
...
>>>>>> current-branch
...
this part is in agreement between the two branches 
   - no conflict exists
...
\end{verbatim}

There are two basic ways of helping Git in resolving merge conflict. The first is to edit the files with the markers above, remove the markers and make sure the files contain the appropriately merged version. After the conflicts are resolved manually, we need to a perform a commit to inform Git that we resolved the conflict. The second way to resolve conflicts is to use a graphic merge tool, for example by running the command \texttt{git mergetool}.



\subsubsection{Remote Git}

In many cases developers need to work with Git respositories on other servers. In this case, the first stage is to clone the respository on a local computer using the \texttt{git clone respository} command where \texttt{respository} has a pattern such as \texttt{ssh://username@address.com/path/projectName.git}. For example the following command creates a cloned repository of the \texttt{projectName.git} repository in the local \texttt{projectName} directory. The server from which the repsository was cloned is referred to as \texttt{origin}.

<<eval=FALSE>>=
git clone ssh://username@address.com/path/projectName.git
@

At this point the developer can move into the newly created directory and start editing files, adding files, and committing as outlined in the previous section. One major difference is that the commit will be stored in the local index rather than other remote servers. To propagate the commits to other servers we need to execute the \texttt{git push} command that is usually preceeded by the \texttt{git pull} command. 

The \texttt{git pull} command contacts \texttt{origin} and checks for recent updates. If a newer version is found on \texttt{origin}, that version is downloaded to the local directory and merged with the working version (if conflicts occur they need to be resolved manually). 
The \texttt{git push} command transmits local commits to \texttt{origin}.

\subsubsection{Additional Features}

We describe below a few commonly used additional features of Git.

We saw above how to add files to a Git repository. Git provides additional file system funcationality such as \texttt{git mv file1 file2} for moving or renaming a file and \texttt{git rm file} for removing a file. As in \texttt{git add} these commands also require a subsequent \texttt{git commit} command to update the repository with the change. 

The command \texttt{git log} prints the respository history: the commits annotated with their date, author, files that were changed, and commit message. Note below the SHA-1 codes displaying the most recent commits and the commit messages.

<<engine="bash">>=
git log | head
@

The command \texttt{git diff ref1 ref2} displays the difference between two references. For example, the command below prints the diff between the commit on top of \texttt{master} and the one before it. 

<<engine="bash">>=
git diff master~1 master | head 
@

The format of the diff printout takes some getting uesd to. In general lines that start with a minus sign (-) represent deleted lines and lines that start with a plus sign (+) represent newly added lines. 

There are various tools that visualize the Git repository history as a directed graph, such as \texttt{gtk+} (Linux Gnome) and \texttt{gitx} (Mac OS). 

An optional file \texttt{.gitignore} in the main Git directory contains filenames or filename patterns (for example \texttt{*.log}) that should be ignored by the Git respository. This prevents Git from printing a long list of untracked files when executing the \texttt{git status} command that need not be tracked or considered for addition to the respository.


\subsection{Github}



\subsection{Subversion} 

%-----------------------------------
\section{Build Tools}
\subsection{Make}
\subsection{Ant}
\subsection{Gradle}


%-----------------------------------
\section{Exceptions}

Code can fail due to a variety of reasons. Examples include inadmissable input, incorrect logic, and undefined values such as division by zero. It is important to not let the code fail inappropriately and rather handle it in a carefully designed manner. 

Traditionally, handling potential failures was done by checking input carefully before entering a function and making sure the output value is properly assigned. In the calling enviornment, the value returned from the function is checked again and handled appropriately if the returned value indicates a failure.

Below is an example in C++ where a function attempts to insert an object into a list in a specific position. The code first check if the list is long enough and if not returns with a specific code (-1). Otherwise, the function calls \texttt{insert\_res} and returns the return value from that function.

<<engine="python",eval=FALSE>>=
int insertInPosition(List L, int pos, Object o) {
  if (pos >= L.size()) 
    return(-1);  // return -1 value for a fail
  int insert_res = L.insert(pos, o);
  return(insert_res);
}
@

The process described above requires (a) writing code that will diagnose whether there is a problem and (b) handle the problem, and so at multiple key places such as function entry points and function return. Doing so eventually leads to writing duplicated code that is hard to maintain. 

Exception handling is a more effective way of handling code failures that at this point is supported in many major programming languages, including C++, Java, Python, and R. We describe below exception handling in Python. Exception handling in other languages is similar and once the concept is clear it is easy to learn how to use it in any of the languages above.

Exceptions are objects that represent an problematic situation that needs to be logged or handled. Usually, exception classes may be implemented in the language definition or standard library, or may be defined and implemented by the programmer. In either case, exception classes inherit from the base exception class (for example, in Python it is \texttt{BaseException}) or one of its descendents. 

When the appropriate situation is discovered, the exception is activated. This is called throwing an exception. At that point program execution is suspended and is transferred to the try block containing the code that lead to the thrown exception. 

We describe the process below in the case of the Python programming languages. The process is similar (though some differences remain) in other programming languages. 

The code below computes a mathematical expression, and it requires that the argument be a positive integer. We thus check the argument and throw an exception if needed. 

<<engine="python",eval=FALSE>>=
import math

def foo(x):
  if not isinstance(x, int):
    raise TypeError("arguments to foo should be integers")
  if x <= 0:
    raise ValueError("arguments to foo should be positive")
  return(x + math.log(x))

foo(-3)  # exception triggered and program halted 
foo(3)  # never executed
@

In the example above, we did not have specific code to handle the thrown exception, and thus the program is halted immediately and never reaches the last line. Also, if we have a function that calls another function that raises an exception without exception handling code the program halts and no code afterwards is executed. 

When the program is halted we get a printout of the traceback object that records the program path that lead to the exception (for example which function called the function that triggered the exception). This information is very useful in debugging and in understanding the behavior of complex code. For example, the traceback below shows the path \texttt{bar(3)} followed by \texttt{foo(-x)}.

<<engine="python",eval=FALSE>>=
def bar(x): 
  foo(-x)
  
bar(3)  

## ----------------------------------------------
## ValueError   Traceback (most recent call last)
## <ipython-input-17-2f0fa4d9f487> in <module>()
## ----> 1 bar(3)
##
## <ipython-input-15-a80ffbcd5b6f> in bar(x)
##      1 def bar(x):
## ----> 2  foo(-x)
##      3 

## <ipython-input-12-1165b706a01c> in foo(x)
##      3  raise TypeError("arguments to foo should be integers")
##      4    if x <= 0:
## ----> 5 raise ValueError("arguments to foo should be positive")
##      6    return(x + math.log(x))
##      7 
##
## ValueError: arguments to foo should be positive
@

\subsection{Handling Exceptions}

In order to trigger a more specific handling of the exception (rather than simply terminate the program), we include code that may trigger exceptions in a \texttt{try}-\texttt{except} clause. The code follows the \texttt{try} keyword is executed, and if an exception is triggered execution passes immediately to the code following the \texttt{except} keyword that handles the exception. After exception handling code is finished, the program continues to execute the code following the \texttt{except} block (rather than terminate).

<<engine="python",eval=TRUE>>=
import math

def foo(x):
  if not isinstance(x, int):
    raise TypeError("arguments to foo should be integers")
  if x <= 0:
    raise ValueError("arguments to foo should be positive")
  return(x + math.log(x))

try: 
  foo(-3)  # exception triggered and program halted 
  foo(3)  # never executed
except: 
  print("exception in sequence of foo() calls")
print("program resumes execution and is not terminated")
@

The syntax above catches and handles all exceptions in the same way. We can write custom handling code for different exceptions by including multiple 
\texttt{except} blocks followed by the exception class that they handle. If there are multiple \texttt{except} blocks and an exception occurs, the program executes the exception handling code and then continues after the last \texttt{except} block. An optional block \texttt{else:} is called if no exception has been handled (\texttt{else:}) and an optinoal block \texttt{finally:} is always called and can be used to host cleanup code (e.g., closing a file or database connection).

<<engine="python",eval=TRUE>>=
import math

def foo(x):
  if not isinstance(x, int):
    raise TypeError("arguments to foo should be integers")
  if x <= 0:
    raise ValueError("arguments to foo should be positive")
  return(x + math.log(x))

try: 
  foo(-3)  # exception triggered and program halted 
  foo(3)  # never executed
except TypeError:  # handle TypeError exceptions
  print("Incorrect Type in sequence of foo() calls")
except ValueError:  # handle ValueError exceptions
  print("Non-positive value in sequence of foo() calls")
else: 
  print("no exceptions handled")  
finally:
  print("always handled")  
print("program resumes execution and is not terminated")
@

If we want to write \texttt{except} blocks that handles exceptions, but also terminate the program with printing the traceback object to the console (as if the exception has never been caught) we can include the \texttt{raise} keyword (with no arguments) at the end of the appropriate \texttt{except} block. In this case, the code in the \texttt{except} block up to the \texttt{raise} keyword is executed followed by program termination and printing of the traceback object.

If there are multiple \texttt{except} blocks and an exception is raised, only the first match will execute. An exception can match an \texttt{except} block also if it specifies an exception class that it inherits from. This is useful for handling some exceptions in a particular way, and all other exception in a default way: include the specific exceptions in separate \texttt{except} blocks first followed by an \texttt{except Exception:} block that will handle all remaining exceptions (since all exception classes inherit from the base Exception class). Since the first matching \texttt{except} block is used, multiple \texttt{except} blocks are ordered from more specific exceptions to less specific exceptions.

If we want access to the exception object in the \texttt{except} block, we can modify the syntax \texttt{except TypeError:} to \texttt{except TypeError as e:} that exposes the exception object as \texttt{e} in the block.

<<engine="python",eval=TRUE>>=
import math

def foo(x):
  if not isinstance(x, int):
    raise TypeError("arguments to foo should be integers")
  if x <= 0:
    raise ValueError("arguments to foo should be positive: " + str(x))
  return(x + math.log(x))

try: 
  foo(-3)  # exception triggered and program halted 
  foo(3)  # never executed
except TypeError:  # handle TypeError exceptions
  print("Incorrect Type in sequence of foo() calls")  
except ValueError as e:  # handle ValueError exceptions
  print("Non-positive value in sequence of foo() calls:")
  print(e.args)
print("program resumes execution and is not terminated")
@



\subsection{Custom Exceptions}

In some cases it is useful to define new exception classes that represent specific situations. To  do so we simply specify that it inherits from the base \texttt{Exception} class. The class name usually communicate what went wrong. 


<<engine="python",eval=FALSE>>=
import math

# Custom exception: either type or value error
class InvalidTypeOrValueError(Exception):
  def __init__(self, a_val, a_type):  # custom constructor
    # calls super class constructor (Python 3 syntax)
    super().__init__("incorrect type and value. " + 
      "val: " + str(a_val) + " " + "type: " + str(a_type))
    self.val = a_val
    self.type = a_type
    
def foo(x):
  if not isinstance(x, int) or x<=0:
    raise InvalidTypeOrValueError(x,type(x))
  return(x + math.log(x))
  
try: 
  foo(-3) 
  foo(3)
except InvalidTypeOrValueError as e:
  print("Incorrect type or value in sequence of foo() calls: ")
  print(e.args)

## Incorrect type or value in sequence of foo() calls: 
## ("incorrect type and value. val: -3 type: <class 'int'>",)
@

%-------------------------------------------------------------------
\section{Documentation Tools}

It is useful to write self-documenting code in the sense that the source code files contain significant documentation about the code implementation as well as how to use it. Many programming languages have a built-in documentation format that if the programmer adheres to can generate separate documentation files based on the in-code comments. Below we describe first Docstrings - a built-in documentation format used in Python, and later describe Javadoc - a similar format that is used in Java.

\subsection{Docstrings} \label{sec:tools:docstrings}

Python docstrings appear as a string literal in the first statement following the definition of functions, methods, classes, and modules. Below is an example of a docstring documention of the Point class from Chapter~\ref{chap:Python}. 

<<engine="python",eval=FALSE>>=
class Point(object):
  "A point in a two dimensional space"

  def __init__(self, x=0, y=0):
    """Initializes the point object to the origin by default, or otherwise 
    the initializes to the passed x,y arguments."""
    self.x = x
    self.y = y
  def __del__(self):
    "Prints a message when an object is destroyed."
    print "destructing a point object"
  def displayPoint(self):
    "Prints the object by displaying its x and y coordinates."
    print "x: %f, y: %f" % (self.x, self.y)
    
help(Point)  # shows class doctring
help(Point.displayPoint)  # shows method docstring
@

Docstrings can be accessed by the \_\_doc\_\_ attribute on objects inside the program or by typing \texttt{help(X)} in the Python prompt where \texttt{X} is the name of a class, method, function, or module.
 
The docstring for a class should summarize its behavior and list the public methods. The docstring of a function or method should describe its effect, the arguments, the return values, and any restriction on its usage. The docstring for a module should list the classes and functions that are exported by the module with brief high-level descriptions.

Another way to generate documentation from docstrings is using the pydoc program that can be called from the OS prompt as follows: \texttt{pydoc X} where is a built-in or programmer defined module, function, or class (in the latter case of built-in a path should be provided in \texttt{X} including a slash character).

For example, typing at the OS prompt \texttt{pydoc ~/Point.py} produces the following documentation for the Point class above.

\begin{verbatim}
FILE
    /Users/glevanon/tmp.py

CLASSES
    __builtin__.object
        Point

    class Point(__builtin__.object)
     |  Represents a point in a two dimensional space
     |
     |  Methods defined here:
     |
     |  __del__(self)
     |      Prints a message when an object is destroyed
     |
     |  __init__(self, x=0, y=0)
     |      Initializes the point object to the origin by default, 
     |      or otherwise the initializes to the passed x,y arguments
     |
     |  displayPoint(self)
     |      Prints the object by displaying its x and y coordinates
     |  
     
-- truncated --

Adding to the pydoc command the \texttt{-w} flag outputs the generated documentation to a file in an HTML format.
\end{verbatim}

A more sophisticated and recent alternative to pydoc is the Sphinx program that can include math formulas, ipyhton interactive sessions, inheritance diagrams, and figures generated using matplotlib. Since it is considerably more complex than pydoc we do not discuss it in this book. More details about Sphinx are availble at \href{http://sphinx-doc.org}{http://sphinx-doc.org}.

\subsection{Javadoc}



%-----------------------------------
\section{Unit Testing}
\subsection{Unit Testing in Java with JUnit}
\subsection{Unit Testing in Python with Nose}

%-----------------------------------
\section{Program Diagnostics}
\subsection{Debugging}


Core R features some debugging and profiling functionality. Additional debugging and profiling functionality is available through third party packages, as described at the end of this section.

The \texttt{print} and \texttt{cat} functions display values of relevant variables at appropriate positions and can be used while debugging code. Specifically, the \texttt{print} function displays the value of a variable, while the \texttt{cat} function displays the concatenation of values of several variables passed as parameters.

The \texttt{browser} function suspends the execution of the R code, providing a interactive prompt through which the programmer can evaluate variables or execute new R code while debugging. Other options include stepping through line by line (by typing \texttt{n}), continuing execution (by typing \texttt{c}), or halting execution (by typing \texttt{Q}). The interactive session below demonstrates debugging with the \texttt{browser} function.

<<engine="Rcpp",eval=FALSE>>=
foo2=function(i) {
	a = i + 1;
	b = a + 1;
	browser();
	a = b + 1;
	return(b)
}
> foo2(3)
Called from: foo2(3)
Browse[1]> a  # display the value of a
[1] 4
Browse[1]> b  # display the value of b
[1] 5
Browse[1]> n  # executes next command
debug: a = b + 1
Browse[2]> c  # continue execution
[1] 5
@

The function \texttt{debug} binds the \texttt{browser} function to a user-specified function, invoking a debug session at each call site of said function.  The \texttt{undebug} cancels the binding.

<<engine="Rcpp",eval=FALSE>>=
foo3=function(i) {
	a = i + 1;
	b = a + 1;
	a = b + 1;
	return(b)
}
> debug(foo3)
> foo3(1)
debugging in: foo3(1)
debug: {
    a = i + 1
    b = a + 1
    a = b + 1
    return(b)
}
Browse[2]> n  # execute first command
debug: a = i + 1
Browse[2]> n  # execute next command
debug: b = a + 1
Browse[2]> a  # display value of a
[1] 2
Browse[2]> p=2*a+2  # define a new variable
Browse[2]> p
[1] 6
Browse[2]> n  # executes next command
debug: a = b + 1
Browse[2]> b
[1] 3
Browse[2]> c  # continue execution
exiting from: foo3(1)
[1] 3
> undebug(foo3)
@

The \texttt{trace} function accepts the name of a function as a parameter and prints the function call with the passed arguments each time the function executes. If an error occurs, the variable \texttt{.Traceback}, a character array containing the currently active function calls, appears in the workspace.

Additional debugging functionality is available from contributed packages. In particular,  the \texttt{debug} package \cite{Bravington2003} provides capabilities similar to those of standard graphical debuggers, including a graphical window showing the current command, setting conditional breakpoints, and the opportunity to continue debugging after an error. Another package is \texttt{edtdbg}, which integrates R debugging with external text editors such as vim.

Profiling code refers to diagnosing which parts of the code are responsible for heavy computational efforts and memory usage. The function \texttt{Rprof(X)} starts a profiling session and saves the information to the file \texttt{X}. A call \texttt{Rprof(NULL)} indicates the end of the profiling session and \texttt{summaryRprof} shows the profiling summary.

<<Rprofiler, eval=T>>=
# start profiling
Rprof("diagonsisFile.out")
A = runif(1000)  # generate a vector of random numbers in [0,1]
B = runif(1000)  # generate another random vector
C = eigen(outer(A,B))
Rprof(NULL)  # end profiling
summaryRprof("diagonsisFile.out")
@

Total time is time spent in the function and its respective call subgraph; self time is the time spent only in the function itself. In the example below, the function \texttt{eigen} is responsible for nearly 100\% of the total time, but most of the execution time occurs within other functions called from within \texttt{eigen} (see the second report above). The methods that are called from within \texttt{eigen} are clearly the computational bottleneck, as the outer product and the generation of random samples are not responsible for any substantial total time.

See \href{http://cran.r-project.org/doc/manuals/R-exts.pdf}{http://cran.r-project.org/doc/manuals/R-exts.pdf} for more information on \texttt{Rprof} and a discussion on profiling memory usage. The packages \texttt{proftools} and \texttt{profr} provide additional profiling functionality including analyzing the call graphs.


\subsection{Speed Profiling}
\subsection{Memory Profiling}

%-------------------------------------------------------------------
\section{Libraries}
\subsection{BLAS, LINPACK, and LAPACK}
\subsection{Eigen and Armadillo}
\subsection{GNU Scientific Library}
\subsection{Boost}